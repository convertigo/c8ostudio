scriptContent: 
  - xmlizable: 
    - ↑classname: com.twinsoft.convertigo.beans.common.FormatedContent
    - com.twinsoft.convertigo.beans.common.FormatedContent: 
      →: |
        '/*Begin_c8o_PageImport*/
        import * as _           from ''lodash'';
        import * as backbone    from ''backbone'';
        import * as joint       from ''jointjs'';
        import { ElementRef }   from ''@angular/core'';
        import * as $ from "jquery";
        /*End_c8o_PageImport*/
        /*Begin_c8o_PageDeclaration*/
        	graph = new joint.dia.Graph;
        	paper : joint.dia.Paper
        	cells = [];
        	paperMiniMap : joint.dia.Paper
        	scale : number = 10
        	miniMapScale = 0.2
        	scaleView = 100;
        	dragStartPosition = null;
        	dragStartPositionMiniMap = null;
        	isHorizontal = true;
        	verticalSpace = 170
        	horizontalSpace = 170
        	minimapNavigatorPosition = {
          		minX: 0,
          		minY: 0,
          		maxX: 500,
          		maxY: 300,
        	};
        	strStep = ''com.twinsoft.convertigo.beans.steps.''
        	/*End_c8o_PageDeclaration*/
        /*Begin_c8o_PageConstructor*/		
        		this.local.maxX = 0
        		this.local.maxY = 0
        		/*End_c8o_PageConstructor*/
        /*Begin_c8o_PageFunction*/
        	onGridSizeChanged() {
        	    this.paper.scale(this.scale / 10)
        	}
        	
        	setX(x){
        		if(this.local.maxX < x){
        			this.local.maxX = x;
        		}
        	}
        	setY(y){
        		if(this.local.maxY < y){
        			this.local.maxY = y;
        		}
        	}
        
        	pushToCells(el) {
        		this.cells.push(el);
        	}
        	
        	getCells() {
        		return this.cells;
        	}
        	
        	onMouseMove(event) {
        		console.log("I AM EVENT " + JSON.stringify(event));
        		 if (this.dragStartPosition != null) {
        			// this.c8o.log.debug("Mouse Move : " + JSON.stringify(this.dragStartPosition))
        		    this.paper.translate(
        		    	event.offsetX - this.dragStartPosition.x * this.scale / 10, 
        		        event.offsetY - this.dragStartPosition.y * this.scale / 10);
        			this.paperMiniMap.translate(
        				event.offsetX - this.dragStartPosition.x,
        				event.offsetY - this.dragStartPosition.y
        			)
        		}
            }
        
        	onMouseMoveMiniMap(event) {
        		if(this.dragStartPositionMiniMap != null) {
        			console.log("EVENT x: "+ event.offsetX + " y: "+event.offsetY);
        			console.log(JSON.stringify(this.dragStartPositionMiniMap))
        			this.paperMiniMap.translate(
        				event.offsetX - this.dragStartPositionMiniMap.x * this.miniMapScale,
        				event.offsetY - this.dragStartPositionMiniMap.y * this.miniMapScale
        			);
        			this.paper.translate(
                        event.offsetX - this.dragStartPositionMiniMap.x, 
                        event.offsetY - this.dragStartPositionMiniMap.y);
        		}
        	}
        	
        	makeLink(source, target, label) {
                var link = new joint.shapes.standard.ShadowLink({
        		    source: source,
        		    target: target,
        		    markup: [{
        		        tagName: ''path'',
        		        selector: ''shadow'',
        		        attributes: {
        		            ''fill'': ''none''
        		        }
        		    }, {
        		        tagName: ''path'',
        		        selector: ''line'',
        		        attributes: {
        		            ''fill'': ''none''
        		        }
        		    }, {
        		        tagName: ''text'',
        		        selector: ''label''
        		    }],
        		    attrs: {
        		        line: {
        		            stroke: ''#3c4260'',
        		        }
        			},
        			text: {
        				text: label
        			}
        		});
        		
        		link.addTo(this.graph)
            }
        
        	makeElement(position, text: string, qname: string, className: string, isComplex: boolean, isEmbedded: boolean, refIdEmbed: string) {
                
        		var element;
        		if(!isComplex) {
        			console.log("makeElement isComplex logical node : " + isComplex + ", element concerned is :" + text)
        			element = new joint.shapes.standard.InscribedImage;
        			
        			element.resize(70, 70);
        			element.position(position.x, position.y);
        			element.attr(''root/title'', ''joint.shapes.standard.element'');
        			element.attr(''label/text'', text);
        			element.attr(''label/fill'', ''#fff'');
        			element.attr(''root'', { class: ''pulsar'' });
        			element.attr(''background/fill'', ''#fe854f'');
        			element.attr(''background/fillOpacity'', 0.5);
        			element.attr(''border/stroke'', ''#fe854f'');
        			element.attr(''image'', {
        				xlinkHref: this.c8o.endpoint + ''/.bin?__sequence=GetIcon&className='' + className + ''&large=true&__nolog=true'',
        			});
        			element.prop(''qname'', qname);
        			element.prop(''className'', className);
        			element.prop(''displayName'', text);
        			element.prop(''isComplex'', isComplex);
        			element.prop(''isEmbedded'', isEmbedded);
        			element.prop(''refIdEmbed'', refIdEmbed);
        		} else {
        			element = this.makeComplexElement(position, text, qname, className, isComplex, isEmbedded, refIdEmbed);
        		}
        
        		
        		element.addTo(this.graph);
        		this.setX(position.x + 70 + this.horizontalSpace)
        		this.setY(position.y + 70 + this.verticalSpace)
        		
        		return element;
            }
        
        	makeComplexElement(position, text: string, qname: string, className: string, isComplex: boolean, isEmbedded: boolean, refIdEmbed: string) {
        		
        		let element = new joint.shapes.basic.Rect({
        	        position: {
        				x: position.x, 
        				y: position.y
        			},
        	        size: { 
        				width: 70, 
        				height: 70
        			},
        	        attrs: { 
        				rect: { 
        					fill: ''#E74C3C'' 
        				}, 
        				text: { 
        					text: text 
        				},	
        			},
        			''qname'': qname,
        			''className'': className,
        			''displayName'': text,
        			''isComplex'': isComplex, 
        			''isEmbedded'': isEmbedded,
        			''refIdEmbed'': refIdEmbed
            	});
        		
        		return element;
        	}
        
        	getFlowScale() {
        		var scale = this.paper.scale();
        		var scaleNbr = scale.sx;
        		return scaleNbr;
        	}
        	
        	/*
        		We need to multiply by 100 because the calcul is not good in JS with float number
        	*/
        	zoomOutFlow() {
        		var currentScale = this.getFlowScale();
        		currentScale = currentScale * 100;
        		console.log(''currentScale : '' + currentScale)
        		if(currentScale == 10) {
        			this.getInstance(Events).publish("scaleView", "Zoom min");
        		} else {
        			var newScale = currentScale - 10
        			if(newScale == 0)
        				newScale = 10; // we can go under 0.1 otherwise graph disappears
        			console.log(''newScale : '' + newScale)
        			this.paper.scale(newScale / 100)
        			this.scaleView = newScale;
        		}
        	}
        	
        	zoomInFlow() {
        		var currentScale = this.getFlowScale();
        		currentScale = currentScale * 100;
        		console.log(''currentScale : '' + currentScale)
        		if(currentScale == 100) {
        			this.getInstance(Events).publish("scaleView","Zoom max");
        		} else {
        			var newScale = currentScale + 10
        			console.log(''newScale : '' + newScale)
        			this.paper.scale(newScale / 100)
        			this.scaleView = newScale;
        		}
        	}
        	
        	checkElementOnPoint(x: number, y: number) {
        		 if (this.graph.findModelsFromPoint({ x: x, y: y }).length > 0)
        			return true;
        		else 
        			return false;
        	}
        	
        	walkChildren(nodeObject: any, previous = null, refId) {
        		// refid = id du complex
        		var x;
        		var y;
        		var parent = previous
        		var complexElement;
        		
        		for (var i=0; i < nodeObject.length; i++) {
        			
        			// variablizing data
        			let stepClassName = nodeObject[i].dbo.className.substring(this.strStep.length)
        			let displayName = nodeObject[i].dbo.displayName
        			let parentClassName = parent.attributes[''className''].substring(this.strStep.length)
        			
        			let isComplex = previous.attributes.isComplex;
        			let previousX = previous.attributes.position.x;
        			let previousY = previous.attributes.position.y;
        			
        			if(previous != null) {
        				
        //				if(!previous.attributes.isComplex) {
        //					x = previous.attributes.position.x + this.horizontalSpace
        //					y = previous.attributes.position.y 
        //				}
        				
        				if(stepClassName == "ElseStep") {
        					x = previous.attributes.position.x 
        					y = previous.attributes.position.y + this.verticalSpace
        				} else if (isComplex) {
        					x = previousX;
        					y = previousY;
        				} else {
        					x = previous.attributes.position.x + this.horizontalSpace
        					y = previous.attributes.position.y 
        				}
        				
        			}
        			
        			// getting ref complex id 
        			if(previous.attributes.isComplex) {
        				refId = previous.id
        			}
        			
        			var el = this.makeElement({
        					x : x,
        					y: y
        				}, 
        				nodeObject[i].dbo.displayName,
        				nodeObject[i].dbo.qname,
        				nodeObject[i].dbo.className,
        				nodeObject[i].dbo.isComplex,
        				nodeObject[i].dbo.isEmbedded,
        				refId
        			)
        
        			if(previous.attributes.isComplex) {
        				previous.embed(el)
        				previous.fitEmbeds({
        					deep: true,
        					padding: ''10px''
        				})
        				var complexElement = previous;
        //				previous.resize(500, 500)
        //				previous.fitEmbeds({
        //					deep: true,
        //					padding: ''50px''
        //				})
        
        			}
        			 
        			if(previous.attributes.isComplex == false && el.attributes.isEmbedded == true) {
        				// on chope l''id de référence au quel il faut embedder
        				// on embed l''élément à l''élément de'' l''id
        				// on resize
        				var complex = this.graph.getCell(el.attributes.refIdEmbed);
        //				var complexView = this.paper.findViewByModel(complex);
        				complex.embed(el);
        				
        //				var originalPosition = complex.get(''position'');
        //        		var originalSize = complex.get(''size'');
        //
        //				var newX = originalPosition.x;
        //	        	var newY = originalPosition.y;
        //	        	var newCornerX = originalPosition.x + originalSize.width;
        //	        	var newCornerY = originalPosition.y + originalSize.height;
        //
        //				_.each(complex.getEmbeddedCells(), function(child) {
        //		
        //		            var childBbox = child.getBBox();
        //		
        //		            if (childBbox.x < newX) { newX = childBbox.x; }
        //		            if (childBbox.y < newY) { newY = childBbox.y; }
        //		            if (childBbox.corner().x > newCornerX) { newCornerX = childBbox.corner().x; }
        //		            if (childBbox.corner().y > newCornerY) { newCornerY = childBbox.corner().y; }
        //
        //			        complex.set({
        //			            position: { x: newX, y: newY },
        //			            size: { width: newCornerX - newX, height: newCornerY - newY }
        //			        });
        //	        	});
        
        			// Note that we also pass a flag so that we know we shouldn''t adjust the
        	        // `originalPosition` and `originalSize` in our handlers as a reaction
        	        // on the following `set()` call.
        
        //				complex.set({ size: {width: previous.attributes.position.x, height: previous.attributes.position.y + 75 }})	
        //				if(complexElement != undefined)
        //					complexElement.fitEmbeds({
        //						deep: true,
        //						padding: ''250px''
        //					})
        				
        			}
        			
        			if(previous != null && !previous.attributes.isComplex)
        				var link = this.makeLink(previous, el, "")
        				
        			previous = el
        			
        			var allComplexElements = this.graph.getElements().filter(element => element.attributes.isComplex == true)
        			var tmpComplexElement = [];
        			_.each(allComplexElements, (element) => {
        				
        				console.log("I am element: " + element.attributes.qname)
        				var elementBBox = element.getBBox()
        				
        				var elementX = elementBBox.x;
        				var elementY = elementBBox.y;
        				var elementW = elementBBox.width;
        				var elementH = elementBBox.height;
        				
        				var area = {
        					x: elementX,
        					y: elementY,
        					width: elementW,
        					height: elementH
        				}
        				
        				var modelsInArea = this.graph.findModelsInArea(area).filter(model => model.attributes.isComplex && model.attributes.isEmbedded && model.attributes.id != element.attributes.id);
        				
        				_.each(modelsInArea, (model) =>  {
        					//console.log("I AM unique model: " + JSON.stringify(model));
        					var modelBBox = model.getBBox();
        					if(modelBBox.intersect(elementBBox)) {
        						console.log("INTERSECT elementQname :" + element.attributes.qname + " modelQname " + model.attributes.qname)
        						
        						// choper top left de l''élément (ce qui est au dessus, z-index le plus fort)
        						// choper bottom left du model (ce qui est en dessous, z-index < z-index elem)
        						
        						// notes pour le 13/11/2020
        						// au départ c''était elementTopLeftY mais finalement tu as inversé et tu gardes le TopLeftX just in case
        						var elementBottomLeftY = elementBBox.bottomLeft().y;
        						var elementTopLeftX = elementBBox.topLeft().x;
        						
        						var modelTopLeftY = modelBBox.topLeft().y;
        						var modelBottomLeftX = modelBBox.bottomLeft().x;
        						
        									
        						if(modelTopLeftY < elementBottomLeftY)
        //							console.log("deltaY: " + deltaY)
        							element.position(element.attributes.position.x, element.attributes.position.y + this.verticalSpace)
        //							element.translate(element.attributes.position.x, 500)
        						
        						console.log("INTERSECT modelTopLeftY: " + modelTopLeftY + " elementBottomLeftY: " + elementBottomLeftY)
        					}
        				});
        		
        				element.fitEmbeds({
        					deep: true,
        					padding: { 
        						top: 20,
        						left: 10, 
        						right: 10, 
        						bottom: 20 
        					}
        				});
        
        			});
        			
        			if(nodeObject[i].dbo.children != undefined && nodeObject[i].dbo.children.length > 0) {
        					this.walkChildren(nodeObject[i].dbo.children, previous, refId);
        			}
        
        		}
        	}
        
        	ngAfterViewInit() {
        	    /**
        	     * TODO : Implement Drag & Drop from palette see : https://codepen.io/fxaeberard/pen/reGvjm
        	     * 
        	     */
        		this.global.miniMapIsHidden = false;    
        	    let element = this.flowID as ElementRef
        
                this.paper = new joint.dia.Paper({
                    el: element.nativeElement,
                    width: ''100%'',
                    height: ''600px'',
                    model: this.graph,
                    gridSize: 10,
        			embeddingMode: true,
                    defaultLink: new joint.dia.Link({
                    	attrs: {
                            ''.connection'' : {
                                stroke: ''orange'',
                                strokeWidth: 2
                            }
                        }                
                    }),
        			drawGrid: {
        				name: ''dot'',
        				args: {
        					color: ''white''
        				}
        			},
                    defaultRouter: {
                        name: ''manhattan''
                    },
                    defaultConnector: {
                        name: ''rounded''
                    },
                    validateConnection: function(cellViewS, magnetS, cellViewT, magnetT, end, linkView) {
                        // Prevent connections if not on Magnets from ports
                        if (magnetT == undefined|| magnetS ==undefined)
                            return false
                        else
                            return true
                    }
                });
        
        		// minimap paper view
        		let miniMap = document.getElementById(''paper-multiple-papers-small'')
        	    var paperMiniMap = new joint.dia.Paper({
        	        el: miniMap,
        	        model: this.graph,
        	        width: ''100%'',
        	        height: ''300'',
        	        gridSize: 5,
        	        interactive: { elementMove: false },
        //			drawGrid: {
        //				name: ''mesh'',
        //				args: {
        //					color: ''white''
        //				}
        //			}
        	    });
        		this.paperMiniMap = paperMiniMap;
        	    paperMiniMap.scale(this.miniMapScale);
        		/*miniMap.addEventListener(''mousemove'', e => {
        			// console.log("i am minimap event " + JSON.stringify(e));
        			if (this.dragStartPositionMiniMap != null) {
        				console.log("i am minimap dragPosition " + JSON.stringify(this.dragStartPositionMiniMap));
                    paperMiniMap.translate(
                        e.offsetX - this.dragStartPositionMiniMap.x, 
                        e.offsetY - this.dragStartPositionMiniMap.y);
        	    }
        		})
        		*/
        //paperSmall.$el.css(''pointer-events'', ''none'');
        
        		$(''#minimap-navigator'').width(215);
        		$(''#minimap-navigator'').height(108);
        		
        		// Bind container scrolling
        		$(''#flowContainer'').scroll( e => {
        		  $(''#minimap-navigator'').css(
        		    ''top'',
        		    this.minimapNavigatorPosition.minY + e.target.scrollTop * this.miniMapScale
        		  );
        		  $(''#minimap-navigator'').css(
        		    ''left'',
        		    this.minimapNavigatorPosition.minX + e.target.scrollLeft * this.miniMapScale
        		  );
        		}); 
        		
        		// Bind minimap navigator drag
        		var dragFlag = false;
        		var x = 0;
        		var y = 0;
        		var initialOffset = { x: 0, y: 0 };
        		$(''#minimap-navigator'').mousedown( e => {
        		  dragFlag = true;
        		  x = e.clientX;
        		  y = e.clientY;
        		  initialOffset.x = e.target.offsetLeft;
        		  initialOffset.y = e.target.offsetTop;
        		 console.log("initialOffsetX : " + initialOffset.x + '' initialOffsetY : '' + initialOffset.y)
        		});
        		$(''#minimap-navigator'').mouseup( () => {
        		  dragFlag = false;
        		});
        		$(''#minimap-container'').mouseleave( () =>  {
        		  dragFlag = false;
        		});
        		$(''#minimap-navigator'').mousemove( e => {
        		  if (dragFlag) {
        			
        		    var newX = initialOffset.x + e.clientX - x;
        		    var newY = initialOffset.y + e.clientY - y;
        			console.log(''eClientX : '' + e.clientX + '' eClientY : '' + e.clientY)
        			console.log(''x : '' + x + '' y : '' + y)
        			console.log("newX : " + newX + '' newY:'' + newY)
        		    /*if (this.minimapNavigatorPosition.minY > newY) {
        		      newY = this.minimapNavigatorPosition.minY;
        		    }
        		    if (this.minimapNavigatorPosition.minX > newX) {
        		      newX = this.minimapNavigatorPosition.minX;
        		    }
        		    if (this.minimapNavigatorPosition.maxY < newY) {
        		      newY = this.minimapNavigatorPosition.maxY;
        		    }
        		    if (this.minimapNavigatorPosition.maxX < newX) {
        		      newX = this.minimapNavigatorPosition.maxX;
        		    }*/
        		console.log("newX : " + newX + '' newY:'' + newY)
        		    //$(''#minimap-navigator'').css(''top'', newY);
        		    //$(''#minimap-navigator'').css(''left'', newX);
        			// newX / this.miniMapScale
        			console.log(" i am calcul : " + newX *((this.scale/10) / this.miniMapScale))
        			$(''#flowContainer'').scrollLeft(newX *((this.scale/10) / this.miniMapScale));
        		    $(''#flowContainer'').scrollTop(newY *((this.scale/10) / this.miniMapScale));
        			/*
        		    $(''#flowContainer'').scrollLeft((newX - this.minimapNavigatorPosition.maxX) / this.miniMapScale);
        		    $(''#flowContainer'').scrollTop((newY - this.minimapNavigatorPosition.maxY)  / this.miniMapScale);
        */
        		  }
        		});
           
        
        		this.paper.on(''change:position'', function(cell, newPosition, opt) {
        			
        			// if we manipulate a complex box
        			if (cell.get(''embeds'') && cell.get(''embeds'').length) {
        	            // If we''re manipulating a parent element, let''s store
        	            // it''s original position to a special property so that
        	            // we can shrink the parent element back while manipulating
        	            // its children.
        	            cell.set(''originalPosition'', cell.get(''position''));
                	}
        
        			var parentId = cell.get(''parent'');
                	if (!parentId) return;
        			
        			var parent = this.graph.getCell(parentId);
        			
        			if (!parent.get(''originalPosition'')) parent.set(''originalPosition'', parent.get(''position''));
                	if (!parent.get(''originalSize'')) parent.set(''originalSize'', parent.get(''size''));
        
        			var originalPosition = parent.get(''originalPosition'');
                	var originalSize = parent.get(''originalSize'');
        
        	        var newX = originalPosition.x;
        	        var newY = originalPosition.y;
        	        var newCornerX = originalPosition.x + originalSize.width;
        	        var newCornerY = originalPosition.y + originalSize.height;
        
        			_.each(parent.getEmbeddedCells(), function(child) {
        	
        	            var childBbox = child.getBBox();
        	
        	            if (childBbox.x < newX) { newX = childBbox.x; }
        	            if (childBbox.y < newY) { newY = childBbox.y; }
        	            if (childBbox.corner().x > newCornerX) { newCornerX = childBbox.corner().x; }
        	            if (childBbox.corner().y > newCornerY) { newCornerY = childBbox.corner().y; }
                	});
        
        			// Note that we also pass a flag so that we know we shouldn''t adjust the
        	        // `originalPosition` and `originalSize` in our handlers as a reaction
        	        // on the following `set()` call.
        	        parent.set({
        	            position: { x: newX, y: newY },
        	            size: { width: newCornerX - newX, height: newCornerY - newY }
        	        }, { skipParentHandler: true });
        		});
        //        this.paper.on(''blank:pointerdown'', (event, x, y) => {
        //            this.c8o.log.debug("Mouse Start")
        //            this.dragStartPosition = { x: x * this.scale / 10, y: y * this.scale / 10};
        //        });
        //        
        //        this.paper.on(''cell:pointerup blank:pointerup'', (cellView, x, y) => {
        //            this.c8o.log.debug("Mouse Up")
        //            this.dragStartPosition = null
        //        });
        //
        //		this.paperMiniMap.on(''blank:pointerdown'', (event, x, y) => {
        //            this.c8o.log.debug("Mouse Start")
        //            this.dragStartPositionMiniMap = { x: x , y: y };
        //        });
        //        
        //        this.paperMiniMap.on(''cell:pointerup blank:pointerup'', (cellView, x, y) => {
        //            this.c8o.log.debug("Mouse Up")
        //            this.dragStartPositionMiniMap = null
        //        });
                
                this.paper.on(''cell:pointerclick'',  (cellView) => {
                    this.c8o.log.debug("Step clicked !!!")
        //            cellView.model.attributes.attrs[''.label''].refY = -80
        //            let parents = cellView.model.getAncestors();
        //            
        //            this.c8o.log.debug("I AM LENGTH : " + parents.length)
        //            if(parents.length !== 0) {
        //                for(let i = 0; i < parents.length ; i++) {
        //                    let id = parents[i].id;
        //                    let cell = this.graph.getCell(id);
        //                    cell.attributes.attrs[''.label''].refY = -80 * (i + 1.5);
        //                }
        //            }
                   // this.getAndDisplayStepChilds(cellView)
                })
                
        	}
        	/*End_c8o_PageFunction*/
        '
segment: path-to-flowviewer
title: Title for FlowViewer
↓PageEvent [ngx.components.UIPageEvent-1588052803545]: 
  ↓useJointJS [ngx.components.UICustomAction-1588052817033]: 
    package_dependencies: 
      - xmlizable: 
        - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
        - com.twinsoft.convertigo.beans.common.XMLVector: 
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
            - com.twinsoft.convertigo.beans.common.XMLVector: 
              - java.lang.String: 
                - ↑value: jointjs
              - java.lang.String: 
                - ↑value: 3.1.1
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
            - com.twinsoft.convertigo.beans.common.XMLVector: 
              - java.lang.String: 
                - ↑value: '@types/lodash'
              - java.lang.String: 
                - ↑value: 3.10.1
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
            - com.twinsoft.convertigo.beans.common.XMLVector: 
              - java.lang.String: 
                - ↑value: '@types/jquery'
              - java.lang.String: 
                - ↑value: '>=3.4.1'
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
            - com.twinsoft.convertigo.beans.common.XMLVector: 
              - java.lang.String: 
                - ↑value: '@types/backbone'
              - java.lang.String: 
                - ↑value: 1.4.1
  ↓initDagreAndGraphLib [ngx.components.UICustomAction-1603285635817]: 
    isEnabled: false
    package_dependencies: 
      - xmlizable: 
        - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
        - com.twinsoft.convertigo.beans.common.XMLVector: 
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
            - com.twinsoft.convertigo.beans.common.XMLVector: 
              - java.lang.String: 
                - ↑value: dagre
              - java.lang.String: 
                - ↑value: 0.8.5
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
            - com.twinsoft.convertigo.beans.common.XMLVector: 
              - java.lang.String: 
                - ↑value: graphlib
              - java.lang.String: 
                - ↑value: 2.1.8
    page_ts_imports: 
      - xmlizable: 
        - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
        - com.twinsoft.convertigo.beans.common.XMLVector: 
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
            - com.twinsoft.convertigo.beans.common.XMLVector: 
              - java.lang.String: 
                - ↑value: '* as dagre'
              - java.lang.String: 
                - ↑value: dagre
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
            - com.twinsoft.convertigo.beans.common.XMLVector: 
              - java.lang.String: 
                - ↑value: '* as graphlib'
              - java.lang.String: 
                - ↑value: graphlib
↓Subscribe_Handler [ngx.components.UIEventSubscriber-1588686865663]: 
  topic: dboFocus
  ↓CallSequence [ngx.components.UIDynamicAction-1588686924736]: 
    beanData: '{"ionBean":"CallSequenceAction","requestable":"plain:C8oStudio.GetGraph"}'
    ↓DisplayFlow [ngx.components.UICustomAction-1588687209815]: 
      actionValue: 
        - xmlizable: 
          - ↑classname: com.twinsoft.convertigo.beans.common.FormatedContent
          - com.twinsoft.convertigo.beans.common.FormatedContent: 
            →: |
              '            class walkTree {
                              
                          }
              		    
                  		this.graph.clear();
              // 			console.log("I AM VARS FLOW" + JSON.stringify(vars.flow));
                  		let previous = null
              			var isComplex = false;
              			var refIdEmbed = '''';
                  		for (var i=0; i < vars.flow.length ; i++) {
              				let stepClassName = vars.flow[i].dbo.className.substring(this.strStep.length)
              				console.log("DisplayFlow - stepClassName : " + stepClassName)
              				
              				isComplex = (stepClassName == "XMLComplexStep") ? true : false
              
              				var step = this.makeElement({
              						x: 30 + this.horizontalSpace * i,
              						y: 70
              					},
              					vars.flow[i].dbo.displayName,
              					vars.flow[i].dbo.qname,
              					vars.flow[i].dbo.className,
              					isComplex,
              					false,
              					''''
              				)
              				
              				if(stepClassName == "XMLComplexStep")
              					refIdEmbed = step.id
              				
              				console.log("DisplayFlow - element created: " + JSON.stringify(step))
              				
              				if(previous != null)
              					var link = this.makeLink(previous, step, "")
              
              				previous = step
              
              				if(vars.flow[i].dbo.children != undefined && vars.flow[i].dbo.children.length > 0) {
              					this.walkChildren(vars.flow[i].dbo.children, previous, refIdEmbed)
              					this.paper.setDimensions(this.local.maxX, this.local.maxY)
              				}
              
                  		}
              
              //			this.walkChildren(vars.flow, null)
                  		resolve();
              '
      ↓flow [ngx.components.UIControlVariable-1588693303067]: 
        varValue: 
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
            - MobileSmartSourceType: source:{"filter":"Sequence","project":"C8oStudio","input":"listen(['C8oStudio.GetChildren'])?.array","model":{"data":[{"sequence":"C8oStudio.GetGraph","marker":""}],"path":"?.array","prefix":"","suffix":"","custom":"","useCustom":false}}
    ↓qname [ngx.components.UIControlVariable-1589811848532]: 
      comment: new variable
      varValue: 
        - xmlizable: 
          - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
          - MobileSmartSourceType: script:out
    ↓level [ngx.components.UIControlVariable-1598523209744]: 
      comment: new variable
      varValue: 
        - xmlizable: 
          - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
          - MobileSmartSourceType: plain:100
↓Grid [ngx.components.UIDynamicElement-1588228737881]: 
  beanData: '{"ionBean":"Grid","Height":"plain:"}'
  tagName: ion-grid
  ↓GridRow [ngx.components.UIDynamicElement-1588228741415]: 
    beanData: |
      '{
       "ionBean": "GridRow",
       "Width": "plain:100%",
       "Height": "plain:300px"
      }'
    tagName: ion-row
    ↓GridCol [ngx.components.UIDynamicElement-1588228746957]: 
      beanData: '{"ionBean":"GridCol","SizeXl":"plain:12"}'
      tagName: ion-col
      ↓Div [ngx.components.UIDynamicElement-1600960364621]: 
        beanData: '{"ionBean":"DivTag"}'
        tagName: div
        ↓Tag [ngx.components.UIElement-1600959915099]: 
          tagName: div
          ↓Attr1 [ngx.components.UIAttribute-1600935208423]: 
            attrName: id
            attrValue: 
              - xmlizable: 
                - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
                - MobileSmartSourceType: plain:flowContainer
          ↓Div [ngx.components.UIDynamicElement-1588137806849]: 
            beanData: '{"ionBean":"DivTag"}'
            identifier: flowID
            tagName: div
            ↓Attr [ngx.components.UIAttribute-1588238054179]: 
              attrName: (document:mousemove)
              attrValue: 
                - xmlizable: 
                  - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
                  - MobileSmartSourceType: plain:onMouseMove($event)
              isEnabled: false
          ↓Attr [ngx.components.UIAttribute-1603209802305]: 
            attrName: style
            attrValue: 
              - xmlizable: 
                - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
                - MobileSmartSourceType: 'script:(this.global.miniMapIsHidden) ? ''height: 600px;'' : ''height: 300px;'''
        ↓Style [ngx.components.UIStyle-1600961212571]: 
          styleContent: 
            - xmlizable: 
              - ↑classname: com.twinsoft.convertigo.beans.common.FormatedContent
              - com.twinsoft.convertigo.beans.common.FormatedContent: 
                →: |
                  '/**
                   * Custom properties (sometimes referred to as CSS variables or cascading variables)
                   * are entities defined by CSS authors that contain specific values to be reused throughout a document.
                   * They are set using custom property notation, e.g.: --main-color: black;
                   * and are accessed using the var() function, e.g.: color: var(--main-color);
                   * You can find below your component''s properties you can customize within the page.
                   * If you''d like to make some customizations for whole app, please see your app Style & Theme components.
                   * For more informations see https://ionicframework.com/docs/theming.
                  **/
                  //--ion-grid-column-padding	//Padding for the Column
                  //--ion-grid-column-padding-lg	//Padding for the Column on lg screens and up
                  //--ion-grid-column-padding-md	//Padding for the Column on md screens and up
                  //--ion-grid-column-padding-sm	//Padding for the Column on sm screens and up
                  //--ion-grid-column-padding-xl	//Padding for the Column on xl screens and up
                  //--ion-grid-column-padding-xs	//Padding for the Column on xs screens and up
                  //--ion-grid-columns	//The number of total Columns in the Grid
                  max-height:300px !important;
                  '
        ↓divToolsBar [ngx.components.UIDynamicElement-1603111118345]: 
          beanData: '{"ionBean":"DivTag"}'
          tagName: div
          ↓Attr [ngx.components.UIAttribute-1603111139643]: 
            attrName: class
            attrValue: 
              - xmlizable: 
                - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
                - MobileSmartSourceType: plain:flowToolsBar
          ↓zoomInIcon [ngx.components.UIDynamicElement-1603111200661]: 
            beanData: |
              '{
               "ionBean": "Icon",
               "IconName": "plain:add-circle",
               "IonSize": "plain:default"
              }'
            tagName: ion-icon
            ↓Event [ngx.components.UIControlEvent-1603117358116]: 
              ↓zoomIn [ngx.components.UICustomAction-1603117367900]: 
                actionValue: 
                  - xmlizable: 
                    - ↑classname: com.twinsoft.convertigo.beans.common.FormatedContent
                    - com.twinsoft.convertigo.beans.common.FormatedContent: 
                      →: |
                        '		page.c8o.log.debug(''[MB] ''+ props.actionFunction +'': ''+ props.actionName);
                        		this.zoomInFlow();
                        		resolve();
                        '
          ↓zoomOutIcon [ngx.components.UIDynamicElement-1603111451351]: 
            beanData: |
              '{
               "ionBean": "Icon",
               "IconName": "plain:remove-circle",
               "IonSize": "plain:default"
              }'
            tagName: ion-icon
            ↓Event [ngx.components.UIControlEvent-1603116289649]: 
              ↓zoomOut [ngx.components.UICustomAction-1603116361860]: 
                actionValue: 
                  - xmlizable: 
                    - ↑classname: com.twinsoft.convertigo.beans.common.FormatedContent
                    - com.twinsoft.convertigo.beans.common.FormatedContent: 
                      →: |
                        '		page.c8o.log.debug(''[MB] ''+ props.actionFunction +'': ''+ props.actionName);
                        		this.zoomOutFlow();
                        		resolve();
                        '
          ↓TextItem [ngx.components.UIDynamicElement-1603122489195]: 
            beanData: '{"ionBean":"TextItem"}'
            tagName: ion-text
            ↓Text [ngx.components.UIText-1603121618903]: 
              textValue: 
                - xmlizable: 
                  - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
                  - MobileSmartSourceType: script:[scaleView] + " %"
            ↓Attr [ngx.components.UIAttribute-1603122609751]: 
              attrName: class
              attrValue: 
                - xmlizable: 
                  - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
                  - MobileSmartSourceType: plain:textScaleView
          ↓Tag [ngx.components.UIElement-1603121593293]: 
            selfClose: true
            tagName: hr
          ↓miniMapIcon [ngx.components.UIDynamicElement-1603114846786]: 
            beanData: '{"ionBean":"Icon","IconName":"plain:map"}'
            tagName: ion-icon
            ↓Event [ngx.components.UIControlEvent-1603207192700]: 
              ↓showOrHideMiniMap [ngx.components.UICustomAction-1603207209276]: 
                actionValue: 
                  - xmlizable: 
                    - ↑classname: com.twinsoft.convertigo.beans.common.FormatedContent
                    - com.twinsoft.convertigo.beans.common.FormatedContent: 
                      →: |
                        '		page.c8o.log.debug(''[MB] ''+ props.actionFunction +'': ''+ props.actionName);
                        		if(this.global.miniMapIsHidden) {
                        			this.global.miniMapIsHidden = false;
                        		} else {
                        			this.global.miniMapIsHidden = true;
                        			this.paper.setDimensions(''100%'', ''600px'');
                        		}
                        		resolve();
                        '
      ↓Style [ngx.components.UIStyle-1600961167941]: 
        styleContent: 
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.FormatedContent
            - com.twinsoft.convertigo.beans.common.FormatedContent: 
              →: |
                '/**
                 * Custom properties (sometimes referred to as CSS variables or cascading variables)
                 * are entities defined by CSS authors that contain specific values to be reused throughout a document.
                 * They are set using custom property notation, e.g.: --main-color: black;
                 * and are accessed using the var() function, e.g.: color: var(--main-color);
                 * You can find below your component''s properties you can customize within the page.
                 * If you''d like to make some customizations for whole app, please see your app Style & Theme components.
                 * For more informations see https://ionicframework.com/docs/theming.
                **/
                //--ion-grid-column-padding	//Padding for the Column
                //--ion-grid-column-padding-lg	//Padding for the Column on lg screens and up
                //--ion-grid-column-padding-md	//Padding for the Column on md screens and up
                //--ion-grid-column-padding-sm	//Padding for the Column on sm screens and up
                //--ion-grid-column-padding-xl	//Padding for the Column on xl screens and up
                //--ion-grid-column-padding-xs	//Padding for the Column on xs screens and up
                //--ion-grid-columns	//The number of total Columns in the Grid
                max-height:300px !important;
                '
    ↓GridCol1 [ngx.components.UIDynamicElement-1600682513448]: 
      beanData: '{"ionBean":"GridCol","SizeXl":"plain:2"}'
      isEnabled: false
      tagName: ion-col
      ↓Tag [ngx.components.UIElement-1600681837711]: 
        tagName: div
        ↓Attr [ngx.components.UIAttribute-1600681920905]: 
          attrName: id
          attrValue: 
            - xmlizable: 
              - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
              - MobileSmartSourceType: plain:paper-multiple-papers-small
        ↓Attr1 [ngx.components.UIAttribute-1600682197627]: 
          attrName: (document:mousemove)
          attrValue: 
            - xmlizable: 
              - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
              - MobileSmartSourceType: plain:onMouseMove($event)
  ↓GridRow1 [ngx.components.UIDynamicElement-1588228813856]: 
    beanData: '{"ionBean":"GridRow","Height":"plain:350"}'
    tagName: ion-row
    ↓GridCol [ngx.components.UIDynamicElement-1588228819248]: 
      beanData: '{"ionBean":"GridCol"}'
      tagName: ion-col
      ↓RangeSlider [ngx.components.UIDynamicElement-1588159080969]: 
        beanData: |
          '{
           "ionBean": "Range",
           "Min": "plain:1",
           "Max": "plain:10",
           "Snaps": "plain:true"
          }'
        isEnabled: false
        tagName: ion-range
        ↓Attr [ngx.components.UIAttribute-1588159106785]: 
          attrName: '[(ngModel)]'
          attrValue: 
            - xmlizable: 
              - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
              - MobileSmartSourceType: script:scale
        ↓Attr1 [ngx.components.UIAttribute-1588159608396]: 
          attrName: (ngModelChange)
          attrValue: 
            - xmlizable: 
              - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
              - MobileSmartSourceType: script:onGridSizeChanged()
      ↓Text [ngx.components.UIText-1594042417780]: 
        isEnabled: false
        textValue: 
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
            - MobileSmartSourceType: plain:Show horizontally
      ↓ToggleButton [ngx.components.UIDynamicElement-1594041057759]: 
        beanData: |
          '{
           "ionBean": "Toggle",
           "ControlName": "plain:name1594041057759",
           "DoubleBinding": "script:isHorizontal"
          }'
        isEnabled: false
        tagName: ion-toggle
      ↓Directive [ngx.components.UIControlDirective-1594041985238]: 
        directiveExpression: this.isHorizontal
        directiveName: If
        isEnabled: false
        ↓Button [ngx.components.UIDynamicElement-1594042311511]: 
          beanData: '{"ionBean":"Button"}'
          tagName: ion-button
      ↓Tag [ngx.components.UIElement-1600690556904]: 
        tagName: div
        ↓Attr [ngx.components.UIAttribute-1600690556907]: 
          attrName: id
          attrValue: 
            - xmlizable: 
              - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
              - MobileSmartSourceType: plain:paper-multiple-papers-small
        ↓Attr1 [ngx.components.UIAttribute-1600690556910]: 
          attrName: (document:mousemove)
          attrValue: 
            - xmlizable: 
              - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
              - MobileSmartSourceType: plain:onMouseMoveMiniMap($event)
          isEnabled: false
      ↓Tag1 [ngx.components.UIElement-1600877872727]: 
        tagName: div
        ↓Attr [ngx.components.UIAttribute-1600877917499]: 
          attrName: id
          attrValue: 
            - xmlizable: 
              - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
              - MobileSmartSourceType: plain:minimap-navigator
      ↓Attr [ngx.components.UIAttribute-1600877980416]: 
        attrName: id
        attrValue: 
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
            - MobileSmartSourceType: plain:minimap-container
      ↓Attr1 [ngx.components.UIAttribute-1603206788743]: 
        attrName: style
        attrValue: 
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
            - MobileSmartSourceType: 'script:(this.global.miniMapIsHidden) ? ''visibility: hidden;'' : ''visibility: visible;'''
↓Subscribe_Handler1 [ngx.components.UIEventSubscriber-1603124103143]: 
  isEnabled: false
  topic: scaleView
  ↓Toast [ngx.components.UIDynamicAction-1603124134840]: 
    beanData: |
      '{
       "ionBean": "ToastAction",
       "message": "script:out",
       "position": "plain:middle"
      }'