scriptContent: 
  - xmlizable: 
    - ↑classname: com.twinsoft.convertigo.beans.common.FormatedContent
    - com.twinsoft.convertigo.beans.common.FormatedContent: 
      →: |
        '/*Begin_c8o_PageImport*/
        import * as _           from ''lodash'';
        import * as backbone    from ''backbone'';
        import * as joint       from ''jointjs'';
        import { ElementRef }   from ''@angular/core'';
        import * as $ from "jquery";
        /*End_c8o_PageImport*/
        /*Begin_c8o_PageDeclaration*/
        	graph = new joint.dia.Graph;
        	paper : joint.dia.Paper
        	paperMiniMap : joint.dia.Paper
        	scale : number = 10
        	miniMapScale = 0.2
        	dragStartPosition = null;
        	dragStartPositionMiniMap = null;
        	isHorizontal = true;
        	verticalSpace = 170
        	horizontalSpace = 170
        	minimapNavigatorPosition = {
          		minX: 0,
          		minY: 0,
          		maxX: 500,
          		maxY: 250,
        	};
        	
        	strStep = ''com.twinsoft.convertigo.beans.steps.''
        	cdinalStepsList = [''IfThenElseStep'', ''ThenStep'', ''ElseStep'']
        	/*End_c8o_PageDeclaration*/
        /*Begin_c8o_PageConstructor*/		
        		this.local.maxX = 0
        		this.local.maxY = 0
        		/*End_c8o_PageConstructor*/
        /*Begin_c8o_PageFunction*/
        	onGridSizeChanged() {
        	    this.paper.scale(this.scale / 10)
        	}
        	
        	setX(x){
        		if(this.local.maxX < x){
        			this.local.maxX = x;
        		}
        	}
        	setY(y){
        		if(this.local.maxY < y){
        			this.local.maxY = y;
        		}
        	}
        
        	onMouseMove(event) {
        		console.log("I AM EVENT " + JSON.stringify(event));
        		 if (this.dragStartPosition != null) {
        			// this.c8o.log.debug("Mouse Move : " + JSON.stringify(this.dragStartPosition))
        		    this.paper.translate(
        		    	event.offsetX - this.dragStartPosition.x * this.scale / 10, 
        		        event.offsetY - this.dragStartPosition.y * this.scale / 10);
        			this.paperMiniMap.translate(
        				event.offsetX - this.dragStartPosition.x,
        				event.offsetY - this.dragStartPosition.y
        			)
        		}
            }
        
        	onMouseMoveMiniMap(event) {
        		if(this.dragStartPositionMiniMap != null) {
        			console.log("EVENT x: "+ event.offsetX + " y: "+event.offsetY);
        			console.log(JSON.stringify(this.dragStartPositionMiniMap))
        			this.paperMiniMap.translate(
        				event.offsetX - this.dragStartPositionMiniMap.x * this.miniMapScale,
        				event.offsetY - this.dragStartPositionMiniMap.y * this.miniMapScale
        			);
        			this.paper.translate(
                        event.offsetX - this.dragStartPositionMiniMap.x, 
                        event.offsetY - this.dragStartPositionMiniMap.y);
        		}
        	}
        
        	addLink(source, dest, isHorizontal, label) {
        		
        	var link = new joint.shapes.standard.ShadowLink({
        	    source: source,
        	    target: dest,
        //	    vertices: [{ x: 150, y: 350 }, { x: 300, y: 280 }],
        //	    smooth: true,
        	    markup: [{
        	        tagName: ''path'',
        	        selector: ''shadow'',
        	        attributes: {
        	            ''fill'': ''none''
        	        }
        	    }, {
        	        tagName: ''path'',
        	        selector: ''line'',
        	        attributes: {
        	            ''fill'': ''none''
        	        }
        	    }, {
        	        tagName: ''text'',
        	        selector: ''label''
        	    }],
        	    attrs: {
        	        line: {
        	            stroke: ''#3c4260''
        	        }
        		},
        //	    label: {
        //	      textPath: {
        //	      	selector: ''line'',
        //	        startOffset: ''50%''
        //	      },
        //	      textAnchor: ''middle'',
        //	      textVerticalAnchor: ''middle'',
        //	      text: '''',
        //	      fill: ''#f6f6f6'',
        //	      fontSize: 15,
        //	      fontWeight: ''bold'',
        //	      fontFamily: ''fantasy''
        //	    }
        	});
        	link.appendLabel({
        				attrs : {
        					text: {
        						text: label
        					}
        				}
        			})
        	link.addTo(this.graph)
        //	    var link = new joint.shapes.standard.Link();
        //        link.source(source, {
        //            anchor: {
        //                name: (isHorizontal) ? ''center'' : ''bottom''
        //            }
        //        })
        //        
        //        link.target(dest, {
        //            anchor: {
        //                name: (isHorizontal) ? ''center'' : ''top''
        //            }
        //        })
        //
        //		if(isHorizontal) {
        //			link.appendLabel({
        //				attrs : {
        //					text: {
        //						text: label
        //					}
        //				}
        //			})
        //		}
        //        
        //        link.attr(''line/stroke'', ''white'');
        //        link.connector(''jumpover'', { size: 10 });	
        //        link.addTo(this.graph);
        	}
        	
        	addStep(position, size, text:string, hasChildren:boolean, qname: string, className: string, isStarting: boolean, isHidden: boolean) {
        	   
        let rect; // custom diamond shape for logical nodes 
        //	    if(className.includes("If")) {
        //	        rect = new joint.shapes.basic.Path({
        //				markup: ''<path /><image /><text />'',
        //// 				markup: ''<g class="rotatable"><g class="scalable"><path/></g><image /><text/></g>'',
        //	            position: position,
        //	            size: { width: 70, height: 70 },
        //	            ports: {
        //	                groups: {
        //	                    ''source'': {
        //	                        position: ''right'',
        //	                        attrs: {
        //	                            ''.joint-port-body'' : {
        //	                                fill: ''orange'',
        //	                                magnet: true
        //	                            }
        //	                        }
        //	                    },
        //	                    ''dest'': {
        //	                        position: ''left'',
        //	                        attrs: {
        //	                            ''.joint-port-body'' : {
        //	                                fill: ''green'',
        //	                                magnet: true
        //	                            }
        //	                        }
        //	                    }
        //	                },
        //	                items: [{
        //	                    group: ''source'',
        //	                    args: {}, // extra arguments for the port layout function, see `layout.Port` section
        //	                },
        //	                {
        //	                    group: ''dest'',
        //	                    args: {}, // extra arguments for the port layout function, see `layout.Port` section
        //	                }]
        //	            },
        //	            attrs: {
        //	                path: { 
        //	                    // d: ''M 30 0 L 60 30 30 60 0 30 z'',
        //						d: ''M 0 0 a 1 1 0 0 0 10 0 A 1 1 0 0 0 0 0'', 
        //	                    fill: ''blue'' 
        //	                },
        //	                ''text'': { 
        //	                    text: text, 
        //	                    fill: ''white'' 
        //	               },
        //					image: {
        //	                    ''xlink:href'': this.c8o.endpoint + ''/.bin?__sequence=GetIcon&className='' + className + ''&large=true&__nolog=true'',
        //	                    width: 32,
        //	                    height: 32,
        //	                    ref: ''rect'',
        //	                    refY: ''0.27'',
        //	                    refX: ''0.27''
        //                	}
        //	            },
        //	            qname: qname,
        //	            className: className,
        //	            isStarting: isStarting
        //	         })
        //
        //			if(isHidden)
        //				rect.attr(''./display'', ''none'')
        				
        //	    } else {
        	       
        //        rect = new joint.shapes.basic.Circle( { 
        //            markup: ''<g class="rotatable"><g class="scalable"><circle class="circle"/></g><image/><text/></g>'',
        //            position: position,
        //            size: size,
        //            ports: {
        //                groups: {
        //                    ''source'': {
        //                        position: ''right'',
        //                        attrs: {
        //                            ''.joint-port-body'' : {
        //                                fill: ''orange'',
        //                                magnet: true
        //                            }
        //                        }
        //                    },
        //                    ''dest'': {
        //                        position: ''left'',
        //                        attrs: {
        //                            ''.joint-port-body'' : {
        //                                fill: ''green'',
        //                                magnet: true
        //                            }
        //                        }
        //                    }
        //                },
        //                items: [{
        //                    group: ''source'',
        //                    args: {}, // extra arguments for the port layout function, see `layout.Port` section
        //                },
        //                {
        //                    group: ''dest'',
        //                    args: {}, // extra arguments for the port layout function, see `layout.Port` section
        //                }]
        //            },            
        //            attrs: {
        //                circle: {
        //					r: 50,
        //					cx: 50,
        //                    fill: hasChildren ? ''#222222'' : ''blue'',
        //                    strokeDasharray: 2,
        //                    strokeWidth: 2,
        //                    stroke: hasChildren ? ''white'' : null 
        //                },
        //// 				path: { 
        ////	                    d: ''M 0 0 a 1 1 0 0 0 10 0 A 1 1 0 0 0 0 0'', 
        ////	                    fill: ''blue'' 
        ////	                },
        //                text: {
        //                    text: text,
        //                    fill: ''white'',
        //                    ref:''rect'',
        //                    refY: ''.7''
        //                  },
        ////                text:
        ////                {
        ////                    text: text,
        ////                    fill: ''white''
        ////                },
        //                image: {
        //                    ''xlink:href'': this.c8o.endpoint + ''/.bin?__sequence=GetIcon&className='' + className + ''&large=true&__nolog=true'',
        //                    width: 32,
        //                    height: 32,
        //                    ref: ''rect'',
        //                    refY: ''0.27'',
        //                    refX: ''0.27''
        //                }
        //            },
        //            qname: qname,
        //            className: className,
        //            isStarting: isStarting
        //        });
        
        
        //var inscribedImage = new joint.shapes.standard.InscribedImage();
        //inscribedImage.resize(70, 70);
        //inscribedImage.position(position.x, position.y);
        //// inscribedImage.attr(''root/tabindex'', 11);
        //inscribedImage.attr(''root/title'', ''joint.shapes.standard.InscribedImage'');
        //inscribedImage.attr(''label/text'', text);
        //inscribedImage.attr(''label/fill'', ''#fff'');
        //inscribedImage.attr(''root'', { class: ''pulsar'' });
        //inscribedImage.attr(''background/fill'', ''#fe854f'');
        //inscribedImage.attr(''background/fillOpacity'', 0.5);
        //inscribedImage.attr(''border/stroke'', ''#fe854f'');
        //// inscribedImage.attr(''root/style'', '' @keyframes pulse { from { stroke-width: 3px; stroke-opacity: 1; transform-origin: center; transform: scale(0.3); } to { stroke-width: 0; stroke-opacity: 0; transform-origin: center; transform: scale(0.5); } } animation: pulse 2s infinite'');
        //inscribedImage.attr(''image'', {
        //	xlinkHref: this.c8o.endpoint + ''/.bin?__sequence=GetIcon&className='' + className + ''&large=false&__nolog=true'',
        //	});
        //inscribedImage.attr(''image/width'', 16);
        //inscribedImage.attr(''image/height'', 16);
        //inscribedImage.prop(''qname'', qname);
        //inscribedImage.prop(''className'', className);
        ////console.log(" I AM SHAPE " + JSON.stringify(inscribedImage));
        ////	                    width: 32,
        ////	                    height: 32,
        ////	                    ref: ''rect'',
        ////	                    refY: ''0.27'',
        ////	                    refX: ''0.27''
        //inscribedImage.addTo(this.graph);
        //this.setX(position.x + 70 + this.horizontalSpace)
        //this.setY(position.y + 70 + this.verticalSpace)
        
        var headeredRectangle = new joint.shapes.standard.HeaderedRectangle();
        headeredRectangle.resize(100, 100);
        headeredRectangle.position(position.x, position.y);
        headeredRectangle.attr(''root/tabindex'', 12);
        headeredRectangle.attr(''root/title'', ''joint.shapes.standard.HeaderedRectangle'');
        headeredRectangle.attr(''header/fill'', ''#000000'');
        headeredRectangle.attr(''header/fillOpacity'', 1);
        headeredRectangle.attr(''headerText/text'', text);
        headeredRectangle.attr(''headerText/fill'', "#FFFFFF");
        headeredRectangle.attr(''body/fill'', ''#fe854f'');
        headeredRectangle.attr(''body/fillOpacity'', 1);
        //headeredRectangle.attr(''bodyText/text'', ''Headered\nRectangle'');
        headeredRectangle.prop(''qname'', qname);
        headeredRectangle.prop(''className'', className);
        headeredRectangle.addTo(this.graph);
        this.setX(position.x + 100 + this.horizontalSpace)
        this.setY(position.y + 100 + this.verticalSpace)
        
        //joint.shapes.devs.Model = joint.shapes.devs.Model.extend({
        //
        //  markup: ''<g class="rotatable"><g class="scalable"><circle class="body"/></g><text class="label"/><g class="inPorts"/><g class="outPorts"/></g>'',
        //  portMarkup: ''<g class="port port<%= id %>"><rect class="port-body"/><text class="port-label"/></g>'',
        //
        //  defaults: joint.util.deepSupplement({
        //
        //    type: ''devs.CircleModel'',
        //    attrs: {
        //      ''.body'': {
        //        r: 50,
        //        cx: 50,
        //        stroke: ''blue'',
        //        fill: ''lightblue''
        //      },
        //      ''.label'': {
        //        text: ''Circle Model'',
        //        ''ref-y'': 0.5,
        //        ''y-alignment'': ''middle''
        //      },
        //      ''.port-body'': {
        //        width: 10,
        //        height: 10,
        //        x: -5,
        //        stroke: ''gray'',
        //        fill: ''lightgray'',
        //        magnet: ''active''
        //      }
        //    }
        //
        //  }, joint.shapes.devs.Model.prototype.defaults)
        //});
        //
        //
        //
        //var circleModel = new joint.shapes.devs.Model({
        //  position: {
        //    x: 150,
        //    y: 100
        //  },
        //  size: {
        //    width: 100,
        //    height: 100
        //  },
        //  inPorts: [''a''],
        //  outPorts: [''b'']
        //});
        //circleModel.addTo(this.graph)
        //	    }
        
        			if(isHidden)
        				rect.attr(''./display'', ''none'')
                
        //        rect.addTo(this.graph);
                return headeredRectangle
        	}
        	
        	getAndDisplayStepChilds(cellView: joint.dia.CellView) {
        	    this.c8o.callJsonObject(".GetChildren", {
        	        qname: cellView.model.attributes["qname"]
        	    }).then((response, parameters) => {
        	        let previous = null;
        	        let y = 0;
        	        let x = 0;
        			let col = 1;
        			let row = 1;
        	        
        			let parent = cellView
        			
        			let cells = this.graph.getCells();
        //	        let ancestor = parent.model.getAncestors()
        	        for (let i=0; i < response["array"].length; i++) {
        	            let element = response["array"][i]
        	            
        	            let stepClassName = element.className.substring(this.strStep.length)
        	            let parentClassName = parent.model.attributes[''className''].substring(this.strStep.length)
        //	            if(elementIndex == 1) {
        //	                let x = 500
        //	            } else {
        //	                let x = 250
        //	            }
        	            
        				if(!this.isHorizontal) {
        		            // calculate in case it is the first box we are opening
        		            if(i == 0) {
        		                if(previous == null && parentClassName == "IfThenElseStep" && stepClassName == "ThenStep") {
        		                    y = parent.model.attributes.position.y + this.verticalSpace
        	                        x = parent.model.attributes.position.x + this.horizontalSpace
        		                } else if (previous == null && parentClassName == "IfThenElseStep" && stepClassName == "ElseStep") {
        		                    y = parent.model.attributes.position.y + this.verticalSpace
        	                        x = parent.model.attributes.position.x
        		                } else if(previous == null && parentClassName == "ElseStep" || parentClassName == "ThenStep") {
        	                        y = parent.model.attributes.position.y + this.verticalSpace
        	                        x = parent.model.attributes.position.x
        	                    } else if(parentClassName == "SimpleIteratorStep") {
        	                        y = parent.model.attributes.position.y + this.verticalSpace
        	                        x = parent.model.attributes.position.x
        	                    } else if(parent.model.attributes[''isStarting''] == true){
        	                        y = parent.model.attributes.position.y + this.verticalSpace
        	                        x = parent.model.attributes.position.x + this.horizontalSpace
        	                    } else {
        	                        y = parent.model.attributes.position.y + this.verticalSpace
        	                        x = parent.model.attributes.position.x
        	                    }
        		            } else if(previous != null){
        		                // positioning Then box
        		                if(stepClassName == "ThenStep") {
        		                    y = parent.model.attributes.position.y
        		                    x = parent.model.attributes.position.x + this.horizontalSpace
        		                    
        		                // positioning Else box
        		                } else if (stepClassName == "ElseStep") {
        		                    y = parent.model.attributes.position.y + this.verticalSpace
        		                    x = parent.model.attributes.position.x
        		                    
        		                    // positioning Then''s or Else''s children compared to their parent 
        		                } else if (parentClassName == "ElseStep" || parentClassName == "ThenStep") {
        		                    y = parent.model.attributes.position.y + this.verticalSpace
        		                    x = parent.model.attributes.position.x
        		                } else {
        		                    y = previous.attributes.position.y + this.verticalSpace
        		                    x = previous.attributes.position.x
        		                }
        		            } else {
        		            }
        	
        					// if a cell is already on points we move it vertically
        	                if (this.graph.findModelsFromPoint({ x: x, y: y }).length > 0) {
        	                    let elementToMove = this.graph.findModelsFromPoint({ x: x, y: y })
        	                    elementToMove[0].set(''position'', {x: x, y: y + this.verticalSpace})
        	                }
        	
        					// if a box is opened and a new branch created, we move down vertically cells from the main branch
        					// condition checks if there is any cell on left of the current cell
        	                if(this.graph.findModelsFromPoint({x: x - this.horizontalSpace, y: y }).length > 0){
        		
        						// if there is, incrementing col
        						col = col +1;
        						
        						// previous col
        						if(this.graph.findModelsFromPoint({x: x - (this.horizontalSpace * col), y: y})) {
        							// getting the element to move
        							let elementToMove = this.graph.findModelsFromPoint({ x: x - (this.horizontalSpace * col), y: y})
        							if(elementToMove.length > 0)
        								elementToMove[0].set(''position'', {x: x - (this.horizontalSpace * col), y: y + this.verticalSpace})
        						}
        						
        						// 2 col before 
        						if(this.graph.findModelsFromPoint({x: x - (this.horizontalSpace * (col + 1)), y: y})) {
        							// getting the element to move
        							let elementToMove = this.graph.findModelsFromPoint({ x: x - (this.horizontalSpace * (col + 1)), y: y})
        							if(elementToMove.length > 0)
        								elementToMove[0].set(''position'', {x: x - (this.horizontalSpace * (col + 1)), y: y + this.verticalSpace})
        						}
        						
        						
        	                    
        	                    // getting element to move
        	                    let elementToMove = this.graph.findModelsFromPoint({ x: x - this.horizontalSpace, y: y})
        	                    elementToMove[0].set(''position'', {x: x - this.horizontalSpace, y: y + this.verticalSpace })
        	                    
        	                    // getting its successors
        	                    let successors = this.graph.getSuccessors(elementToMove[0]);
        	                    
        	                    for(var j = 0; j < successors.length; j++) {
        	                        // if it''s the first successor no need to move it more than the vertical space
        	                        if(j == 0) {
        	                            successors[j].set(''position'', {x: successors[j].attributes.position.x, y : elementToMove[0].attributes.position.y + this.verticalSpace})
        	                        } else {
        	                            successors[j].set(''position'', {x: successors[j].attributes.position.x, y : elementToMove[0].attributes.position.y + this.verticalSpace * (j +1)})
        	                        }
        	                        
        	                    }
        	                }
        				
        	            
        	            
        	            let step = this.addStep({
        //                        x: cellView.getBBox().topLeft().x + x,
        //                        y: cellView.getBBox().topLeft().y      
        	                      x: x,
        	                      y: y
                            }, 
                            {
                                width: 70,
                                height: 70              
                            }, 
                            element.displayName,
                            element.hasChildren,
                            element.qname,
                            element.className,
                            false,
        					false
                        )
                        
                        // cellView.model.embed(step)
                        
                        if(i == 0)
                            this.addLink(cellView.model, step, this.isHorizontal, stepClassName)
                        
                        if (previous != null && stepClassName != "ElseStep") 
                            this.addLink(previous, step, this.isHorizontal, stepClassName)
                            
                        if (stepClassName == "ElseStep")
                            this.addLink(cellView.model, step, this.isHorizontal, stepClassName)
                        
                        previous = step
                        
                        
        
                        /*
                        if (element.hasChildren) {
                            this.getAndDisplayStepChilds(step.findView(this.paper)) 
                        }
                        */
        			} 
        			
        			/* case we display flow horizontally
        			***************
        			*/
        			else {
        				// calculate in case it is the first box we are opening
        		            if(i == 0) {
        		                if(previous == null && parentClassName == "IfThenElseStep" && stepClassName == "ThenStep") {
        							this.c8o.callJsonObject(".GetChildren", {
        	        					qname: element.qname
        	    					}).then((resp, param) => {
        									let elem = resp[''array''][0];
        									y = parent.model.attributes.position.y
        	                        		x = parent.model.attributes.position.x + this.horizontalSpace
        									// if a cell is already on points we move it horizontally
        					                if (this.graph.findModelsFromPoint({ x: x, y: y }).length > 0) {
        					                    let elementToMove = this.graph.findModelsFromPoint({ x: x, y: y })
        					                    elementToMove[0].set(''position'', {x: x + this.horizontalSpace, y: y})
        // getting its successors
        	                    let successors = this.graph.getSuccessors(elementToMove[0]);
        	                    
        	                    for(var j = 0; j < successors.length; j++) {
        	                        // if it''s the first successor no need to move it more than the horizonal space
        	                        if(j == 0) {
        	                            successors[j].set(''position'', {x: successors[j].attributes.position.x + this.horizontalSpace, y : elementToMove[0].attributes.position.y})
        	                        } else {
        	                            successors[j].set(''position'', {x: successors[j].attributes.position.x + this.horizontalSpace * (j+1), y : elementToMove[0].attributes.position.y})
        	                        }
        	                         
        	                    }					                
        }
        
        									let step = this.addStep(
        										{
        										x: x,
        										y: y
        										},
        										{
        											width: 70,
        											height: 70 	
        										},
        										elem.displayName,
        					                    elem.hasChildren,
        					                    elem.qname,
        					                    elem.className,
        					                    false,
        										false	
        									)
        									
        									this.addLink(cellView.model, step, this.isHorizontal, "true")
        									this.c8o.log.debug("Then async x :" + x)
        									this.c8o.log.debug("Then async y :" + y)
        								return null;
        							});
        		                } else if(previous == null && parentClassName == "ElseStep" || parentClassName == "ThenStep") {
        	                        y = parent.model.attributes.position.y
        	                        x = parent.model.attributes.position.x + this.horizontalSpace
        	                    } else if(parentClassName == "SimpleIteratorStep") {
        	                        y = parent.model.attributes.position.y 
        	                        x = parent.model.attributes.position.x + this.horizontalSpace
        	                    } else if(parent.model.attributes[''isStarting''] == true){
        	                        y = parent.model.attributes.position.y
        	                        x = parent.model.attributes.position.x + this.horizontalSpace
        	                    } else {
        	                        y = parent.model.attributes.position.y
        	                        x = parent.model.attributes.position.x + this.horizontalSpace
        	                    }
        		            } else if(previous != null){
        		                // positioning Then box
        		                if(stepClassName == "ThenStep") {
        		                    y = parent.model.attributes.position.y
        		                    x = parent.model.attributes.position.x + this.horizontalSpace
        		                    
        		                // positioning Else box
        		                } else if (stepClassName == "ElseStep") {
        		                    y = parent.model.attributes.position.y + this.verticalSpace
        		                    x = parent.model.attributes.position.x + this.horizontalSpace
        		                    // positioning Then''s or Else''s children compared to their parent 
        		                } else if (parentClassName == "ElseStep" || parentClassName == "ThenStep") {
        		                    y = parent.model.attributes.position.y 
        		                    x = parent.model.attributes.position.x + this.horizontalSpace
        		                } else {
        		                    y = previous.attributes.position.y
        		                    x = previous.attributes.position.x + this.horizontalSpace
        		                }
        		            } else {
        						if (parentClassName == "IfThenElseStep" && stepClassName == "ElseStep") {			
        										this.c8o.callJsonObject(".GetChildren", {
        				        					qname: element.qname
        				    					}).then((resp, param) => {
        												let elem = resp[''array''][0];
        												y = parent.model.attributes.position.y + this.verticalSpace
        				                        		x = parent.model.attributes.position.x
        												let step = this.addStep(
        													{
        													x: x,
        													y: y
        													},
        													{
        														width: 70,
        														height: 70 	
        													},
        													elem.displayName,
        								                    elem.hasChildren,
        								                    elem.qname,
        								                    elem.className,
        								                    false,
        													false	
        												)
        												
        												
        												this.addLink(cellView.model, step, this.isHorizontal, "false")
        												this.c8o.log.debug("Else async x :" + x)
        												this.c8o.log.debug("Else async y :" + y)
        											return null;
        										});
        							}
        		            }
        
        
        				// if a cell is already on points we move it horizontally
        	                if (this.graph.findModelsFromPoint({ x: x, y: y }).length > 0) {
        	                    let elementToMove = this.graph.findModelsFromPoint({ x: x, y: y })
        	                    elementToMove[0].set(''position'', {x: x + this.horizontalSpace, y: y})
        
        						let successors = this.graph.getSuccessors(elementToMove[0]);
        	                    
        	                    for(var j = 0; j < successors.length; j++) {
        	                        // if it''s the first successor no need to move it more than the horizonal space
        	                        if(j == 0) {
        	                            successors[j].set(''position'', {x: successors[j].attributes.position.x + this.horizontalSpace, y : elementToMove[0].attributes.position.y})
        	                        } else {
        	                            successors[j].set(''position'', {x: successors[j].attributes.position.x + this.horizontalSpace * (j+1), y : elementToMove[0].attributes.position.y})
        	                        }
        	                        
        	                    }
        	                }
        
        					
        
        					// condition checks if there is any cell upper of the current cell
        	                if(this.graph.findModelsFromPoint({x: x, y: y - (this.verticalSpace * row)}).length > 0){
        		
        						
        						// previous row
        						if(this.graph.findModelsFromPoint({x: x, y: y + (this.verticalSpace * row)})) {
        							// getting the element to move
        							let elementToMove = this.graph.findModelsFromPoint({ x: x, y: y + (this.verticalSpace * row)})
        							if(elementToMove.length > 0)
        								elementToMove[0].set(''position'', {x: x + (this.horizontalSpace * row), y: y + this.verticalSpace})
        						}
        						
        //						// 2 col before 
        //						if(this.graph.findModelsFromPoint({x: x - (this.horizontalSpace * (col + 1)), y: y})) {
        //							// getting the element to move
        //							let elementToMove = this.graph.findModelsFromPoint({ x: x - (this.horizontalSpace * (col + 1)), y: y})
        //							if(elementToMove.length > 0)
        //								elementToMove[0].set(''position'', {x: x - (this.horizontalSpace * (col + 1)), y: y + this.verticalSpace})
        //						}
        //						
        //						
        //	                    
        	                    // getting element to move
        	                    let elementToMove = this.graph.findModelsFromPoint({ x: x, y: y - (this.verticalSpace * row)})
        	                    elementToMove[0].set(''position'', {x: x + this.horizontalSpace * row, y: y - this.verticalSpace })
        	                    
        	                    // getting its successors
        	                    let successors = this.graph.getSuccessors(elementToMove[0]);
        
        						this.setSuccessorsPosition(elementToMove[0], successors);
        //	                    
        //	                    for(var j = 0; j < successors.length; j++) {
        //		
        //						if(this.checkElementOnPoint(successors[j].attributes.position.x + this.horizontalSpace, elementToMove[0].attributes.position.y)) {
        //							let element = this.graph.findModelsFromPoint({x: successors[j].attributes.position.x + this.horizontalSpace, y: elementToMove[0].attributes.position.y})
        //							element[0].set(''position'', {x: element[0].attributes.position.x + this.horizontalSpace, y: element[0].attributes.position.y})
        //						}
        //						successors[j].set(''position'', {x: successors[j].attributes.position.x + this.horizontalSpace, y : elementToMove[0].attributes.position.y})
        ////	                        // if it''s the first successor no need to move it more than the horizontal space
        ////	                        if(j == 0) {
        ////	                            successors[j].set(''position'', {x: successors[j].attributes.position.x + this.horizontalSpace, y : elementToMove[0].attributes.position.y})
        ////	                        } else {
        ////	                            successors[j].set(''position'', {x: successors[j].attributes.position.x + this.horizontalSpace * j, y : elementToMove[0].attributes.position.y})
        ////	                        }
        //	                        
        //	                    }
        
        						// if there is, incrementing row
        						row = row +1;
        	                }
        
        			 
        		if(stepClassName != "ThenStep" && stepClassName != "ElseStep") {
        			let step = this.addStep({
        //                        x: cellView.getBBox().topLeft().x + x,
        //                        y: cellView.getBBox().topLeft().y      
        	                      x: x,
        	                      y: y
                            }, 
                            {
                                width: 70,
                                height: 70              
                            }, 
                            element.displayName,
                            element.hasChildren,
                            element.qname,
                            element.className,
                            false,
        					false
                        )
        
        				if(i == 0)
                            this.addLink(cellView.model, step, this.isHorizontal, "")
                        
                        if (previous != null && stepClassName != "ElseStep") 
                            this.addLink(previous, step, this.isHorizontal, "")
                            
                        if (stepClassName == "ElseStep")
                            this.addLink(cellView.model, step, this.isHorizontal, "")
                        
                        previous = step
        		}
        
        				
        //			if(stepClassName == "ThenStep" || stepClassName == "ElseStep") {
        //				// getting parent element, to be able to get current''s element object (so we are getting IfThenElseStep element)
        //	            let elementToMove = this.graph.findModelsFromPoint({ x: parent.model.attributes.position.x, y: parent.model.attributes.position.y})
        //	            
        //				
        //				// getting its successors
        //	            let successors = this.graph.getSuccessors(step, {deep: true});
        //				let toto = successors
        //			}	
        
        //			if(parentClassName == "ThenStep" || parentClassName == "ElseStep") {
        //				// getting then or else box
        //	            let elementToMove = this.graph.findModelsFromPoint({ x: parent.model.attributes.position.x, y: parent.model.attributes.position.y})
        //	            
        //				elementToMove[0].attr(''./display'', ''none'')
        //				// getting its successors
        ////	            let successors = this.graph.getSuccessors(elementToMove[0]);
        ////				let toto = successors
        //			}	
        
        //			 let step = this.addStep({
        ////                        x: cellView.getBBox().topLeft().x + x,
        ////                        y: cellView.getBBox().topLeft().y      
        //	                      x: x,
        //	                      y: y
        //                    }, 
        //                    {
        //                        width: 70,
        //                        height: 70              
        //                    }, 
        //                    element.displayName,
        //                    element.hasChildren,
        //                    element.qname,
        //                    element.className,
        //                    false,
        //					false
        //                )
        
        //                if(i == 0)
        //                    this.addLink(cellView.model, step, this.isHorizontal, stepClassName)
        //                
        //                if (previous != null && stepClassName != "ElseStep") 
        //                    this.addLink(previous, step, this.isHorizontal, stepClassName)
        //                    
        //                if (stepClassName == "ElseStep")
        //                    this.addLink(cellView.model, step, this.isHorizontal, stepClassName)
        //                
        //                previous = step
        
        			} // endelse
        			
        			
                        
                        // cellView.model.embed(step)
                        
        	        } // end for
        	        
        //	        /**
        //	         * Get the top most ancestor and ask it to resize itslef to fit all embeds 
        //	         */
        //            let ancestors = cellView.model["getAncestors"]()
        //            let resizeToFit = (ancestors.length == 0 ? cellView.model: ancestors[ancestors.length-1]) as joint.shapes.basic.Rect
        //            
        //            /**
        //             * Get the the bottom left position before resize
        //             */
        //            let bottomY = resizeToFit.getBBox().bottomLeft().y
        //            let bottomX = resizeToFit.getBBox().bottomLeft().x
        //
        //            /* Now Resize to fit all embedded */
        //            resizeToFit["fitEmbeds"]({
        //                deep: true,
        //                padding: 20
        //            })
        //            
        //            /* get the new bottom left position of the resized box, and compute deltas */ 
        //            let deltaY = resizeToFit.getBBox().bottomLeft().y - bottomY
        //            let deltaX = resizeToFit.getBBox().bottomLeft().x - bottomX
        //            
        //            /* Reposition resized Box by deltaX on the right */
        //            resizeToFit.translate(-deltaX, 0)
        //
        //            /* Now, walk all boxes and find only the ones that are lower than the non resized box and push them down by deltaY */ 
        //            for (let element of this.paper.model.getElements()) {
        //                if (element instanceof joint.shapes.basic.Rect) {
        //                    /* Only for non embedded boxes */ 
        //                    if (element.getParentCell() != resizeToFit)
        //                        if (element.getBBox().topLeft().y > bottomY)
        //                            element.translate(0, deltaY)
        //                }
        //            }
                    return null;
        	    })
        		.fail((error:any)=>{
        			console.log(error);
        		})
        	}
        	
        	checkElementOnPoint(x: number, y: number) {
        		 if (this.graph.findModelsFromPoint({ x: x, y: y }).length > 0)
        			return true;
        		else 
        			return false;
        	}
        	
        	setSuccessorsPosition(element: any, successors: Array<any>) {
        		for(var j = 0; j < successors.length; j++) {
        			if(this.checkElementOnPoint(successors[j].attributes.position.x + this.horizontalSpace, element.attributes.position.y)) {
        				let elmt = this.graph.findModelsFromPoint({x: successors[j].attributes.position.x + this.horizontalSpace, y: element.attributes.position.y})
        				elmt[0].set(''position'', {x: elmt[0].attributes.position.x + this.horizontalSpace, y: elmt[0].attributes.position.y})
        				
        				if(this.checkElementOnPoint(elmt[0].attributes.position.x, elmt[0].attributes.position.y)) {
        					let children = this.graph.getSuccessors(elmt[0]);
        					this.setSuccessorsPosition(elmt[0], children)
        				}
        			}
        			
        			successors[j].set(''position'', {x: successors[j].attributes.position.x + this.horizontalSpace, y : element.attributes.position.y})
        //		    // if it''s the first successor no need to move it more than the horizontal space
        //		    if(j == 0) {
        //		    	successors[j].set(''position'', {x: successors[j].attributes.position.x + this.horizontalSpace, y : element.attributes.position.y})
        //		    } else {
        //		        successors[j].set(''position'', {x: successors[j].attributes.position.x + this.horizontalSpace * j, y : element.attributes.position.y})
        //		    }
        	    }
        	}
        	
        	// nodeObject : GetGraph.array
        	walkChildren(nodeObject: any, previous = null) {
        //		let x = 30;
        //		let y = 30;
        		let isHidden = false
        		let tmpThenStep;
        		let tmpElseStep;
        		// let previous = null;
        		
        		for (var i=0; i < nodeObject.length; i++) {
        			let stepClassName = nodeObject[i].dbo.className.substring(this.strStep.length)
        	//		console.log("I AM PREVIOUS " + JSON.stringify(previous));
        //			if(stepClassName == "ThenStep" || stepClassName == "ElseStep")
        //				isHidden = true
        			
        //			console.log(JSON.stringify(previous));
        //			console.log("previous i" + i)
        //			if (this.checkElementOnPoint(x, y + this.verticalSpace * i)) {
        //	        	let elementToMove = this.graph.findModelsFromPoint({ x: x, y: y + this.verticalSpace * i})
        //	            
        //				x = elementToMove[0].attributes.position.x + this.horizontalSpace;
        //				y = elementToMove[0].attributes.position.y;
        //
        //	        }
        
        //			if(nodeObject[i].dbo.isStarting) {
        //				y = y + this.verticalSpace;
        //				let step = this.addStep({
        ////                        x: cellView.getBBox().topLeft().x + x,
        ////                        y: cellView.getBBox().topLeft().y      
        //	                      x: x,
        //	                      y: y
        //                    }, 
        //                    {
        //                        width: 70,
        //                        height: 70              
        //                    }, 
        //                    nodeObject[i].dbo.displayName,
        //                    false,
        //                    nodeObject[i].dbo.qname,
        //                    nodeObject[i].dbo.className,
        //                    nodeObject[i].dbo.isStarting,
        //					false
        //                )
        //
        ////				previous = step;
        //				
        //			}
        
        			
        			if(previous != null)  { 
        	        	let parentClassName = previous.attributes[''className''].substring(this.strStep.length)
        				
        				var x = previous.attributes.position.x
        				var y = previous.attributes.position.y
        				
        				
        				if (this.checkElementOnPoint(x, y)) {
        		        	let elementToMove = this.graph.findModelsFromPoint({ x: x, y: y})
        		            
        				//	console.log("i am element to move " + JSON.stringify(elementToMove[0]))
        					x = elementToMove[0].attributes.position.x + this.horizontalSpace;
        					y = elementToMove[0].attributes.position.y;
        
        	        	} 
        				if (this.checkElementOnPoint(x, y + this.verticalSpace)) {
        		        	let elementToMove = this.graph.findModelsFromPoint({ x: x, y: y + this.verticalSpace})
        		            elementToMove[0].set(''position'', {x: elementToMove[0].attributes.position.x, y: elementToMove[0].attributes.position.y + this.verticalSpace})
        				//	console.log("i am element to move " + JSON.stringify(elementToMove[0]))
        //					x = elementToMove[0].attributes.position.x + this.horizontalSpace;
        //					y = elementToMove[0].attributes.position.y;
        					
        	        	}
        
        				if(parentClassName == "IfThenElseStep" && stepClassName == "ThenStep") {
        		             y = previous.attributes.position.y
        		             x = previous.attributes.position.x + this.horizontalSpace
        //
        //					var firstChild = nodeObject[i].dbo.children[0];
        //					let step = this.addStep({
        //		//                        x: cellView.getBBox().topLeft().x + x,
        //		//                        y: cellView.getBBox().topLeft().y      
        //			                      x: x,
        //			                      y: y
        //		                    }, 
        //		                    {
        //		                        width: 70,
        //		                        height: 70              
        //		                    }, 
        //		                    firstChild.dbo.displayName,
        //		                    false,
        //		                   	firstChild.dbo.qname,
        //		                    firstChild.dbo.className,
        //		                    firstChild.dbo.isStarting,
        //							isHidden
        //		                )
        //
        //					this.addLink(previous, step, this.isHorizontal, "Then")
        //					previous = step
        //					 if (this.checkElementOnPoint(x, y)) {
        //			        	let elementToMove = this.graph.findModelsFromPoint({ x: x, y: y})
        //						elementToMove[0].set(''position'', {x: x + this.horizontalSpace, y: y})
        //			            let successors = this.graph.getSuccessors(elementToMove[0]);
        //			            if(successors.length > 0) {
        //							this.setSuccessorsPosition(previous, successors);
        //						}
        					//	console.log("i am element to move " + JSON.stringify(elementToMove[0]))
        //						x = elementToMove[0].attributes.position.x + this.horizontalSpace;
        //						y = elementToMove[0].attributes.position.y;
        	
        //		        	}
        
        		                    
        		        // positioning Else box
        		        } else if (parentClassName == "IfThenElseStep" && stepClassName == "ElseStep") {
        		            y = previous.attributes.position.y + this.verticalSpace
        		            x = previous.attributes.position.x
        		       // positioning Then''s or Else''s children compared to their parent 
        		       } else {
        			
        			   }
        
        //			if (this.checkElementOnPoint(x, y)) {
        //				let elementToMove = this.graph.findModelsFromPoint({ x: x, y: y})
        //				elementToMove[0].set(''position'', {x: elementToMove[0].attributes.position.x + this.horizontalSpace, y: y})
        //				let successors = this.graph.getSuccessors(elementToMove[0]);
        //			    if(successors.length > 0) {
        //					this.setSuccessorsPosition(previous, successors);
        //				}
        //					//	console.log("i am element to move " + JSON.stringify(elementToMove[0]))
        ////						x = elementToMove[0].attributes.position.x + this.horizontalSpace;
        ////						y = elementToMove[0].attributes.position.y;
        //	
        //		     }
        
        // si pstepClassName == "ThenStep"
        // 	alors
        // 		firstChild = nodeObject[i].dbo.children[0]
        //		x = previous.attributes.position.x + horizontalSpace
        //		y = previous.attributes.position.y
        // si stepClassName == "ElseStep"
        //	alors 
        // 	 	firstChild = nodeObject[i].dbo.children[0]
        // 		x = previous.attributes.position.x
        // 		y = previous.attributes.position.y + verticalSpace
        //
        //
        // 
        
        				if(parentClassName == "IfThenElseStep" && stepClassName == "ElseStep") {
        					y = previous.attributes.position.y + this.verticalSpace
        		            x = previous.attributes.position.x
        					var firstChild = nodeObject[i].dbo.children[0];
        					let step = this.addStep({
        		//                        x: cellView.getBBox().topLeft().x + x,
        		//                        y: cellView.getBBox().topLeft().y      
        			                      x: x,
        			                      y: y
        		                    }, 
        		                    {
        		                        width: 70,
        		                        height: 70              
        		                    }, 
        		                    firstChild.dbo.displayName,
        		                    false,
        		                   	firstChild.dbo.qname,
        		                    firstChild.dbo.className,
        		                    firstChild.dbo.isStarting,
        							isHidden
        		                )
        
        					this.addLink(previous, step, this.isHorizontal, "Else")
        					
        //					if(this.graph.findModelsFromPoint({x: x + this.horizontalSpace, y: y})) {
        //							// getting the element to move
        //							let elementToMove = this.graph.findModelsFromPoint({ x: x + this.horizontalSpace, y: y})
        //							console.log("i am elementToMove x before setting" + elementToMove[0].attributes.position.x)
        //							if(elementToMove.length > 0)
        //								elementToMove[0].set(''position'', {x: elementToMove[0].attributes.position.x  + (this.horizontalSpace * 2), y: y})
        //							
        //							// console.log("i am step x " + step.attributes.position.x)
        //							console.log("i am elementToMove x after setting" + elementToMove[0].attributes.position.x)					
        //					}
        					console.log("i am typeof " + typeof step)
        //					step.highlight(null/* defaults to cellView.el */, {
        //					    highlighter: {
        //					        name: ''addClass'',
        //					        options: {
        //					            className: ''pulsar''
        //					        }
        //					    }
        //					});
        					
        					previous = step
        
        				}
        				if(stepClassName != "ThenStep" && stepClassName != "ElseStep") {
        					let step = this.addStep({
        		//                        x: cellView.getBBox().topLeft().x + x,
        		//                        y: cellView.getBBox().topLeft().y      
        			                      x: x,
        			                      y: y
        		                    }, 
        		                    {
        		                        width: 70,
        		                        height: 70              
        		                    }, 
        		                    nodeObject[i].dbo.displayName,
        		                    false,
        		                    nodeObject[i].dbo.qname,
        		                    nodeObject[i].dbo.className,
        		                    nodeObject[i].dbo.isStarting,
        							isHidden
        		                )
        
        					if (previous != null && stepClassName == "ThenStep") 
                            	this.addLink(previous, step, this.isHorizontal, stepClassName)
        					if (previous != null && stepClassName == "ElseStep") 
                            	this.addLink(previous, step, this.isHorizontal, stepClassName)
        					if(previous != null) {
        						if(this.graph.findModelsFromPoint({ x: x - this.horizontalSpace, y: y}).length > 0) {
        							let element = this.graph.findModelsFromPoint({ x: x - this.horizontalSpace, y: y})
        							if(element[0].attributes.className.substring(this.strStep.length) == "IfThenElseStep") {
        								this.addLink(previous, step, this.isHorizontal, "Then")
        							} else {
        								this.addLink(previous, step, this.isHorizontal, "")
        							}
        						} else {
        							this.addLink(previous, step, this.isHorizontal, "")
        						}
        						//this.addLink(previous, step, this.isHorizontal, "")
        					}
        					
        //					if(previous != null && parentClassName == "ThenStep") {
        //						this.addLink(previous, step, this.isHorizontal, "Then")
        //					}
        	//	
        					previous = step;
        			}
        				if(nodeObject[i].dbo.children != undefined && nodeObject[i].dbo.children.length > 0) {
        					this.walkChildren(nodeObject[i].dbo.children, previous);
        				} // endif
        			} 
        			
        //			this.minimapNavigatorPosition.maxX = (this.local.maxX * this.miniMapScale) + 150;
        //			this.minimapNavigatorPosition.maxY = (this.local.maxY * this.miniMapScale) + 150;
        			
        //			if(previous != null && stepClassName == "ThenStep") {
        //		    	y = previous.model.attributes.position.y + this.verticalSpace
        //	            x = previous.model.attributes.position.x + this.horizontalSpace
        //		    }
        //			let step = this.addStep({
        ////                        x: cellView.getBBox().topLeft().x + x,
        ////                        y: cellView.getBBox().topLeft().y      
        //	                      x: x,
        //	                      y: y
        //                    }, 
        //                    {
        //                        width: 70,
        //                        height: 70              
        //                    }, 
        //                    nodeObject[i].dbo.displayName,
        //                    false,
        //                    nodeObject[i].dbo.qname,
        //                    nodeObject[i].dbo.className,
        //                    nodeObject[i].dbo.isStarting,
        //					false
        //                )
        //
        //			previous = step;
        
        //			console.log("walkChildren displayName " + nodeObject[i].displayName)
        //			console.log("walkChildren qname " + nodeObject[i].qname)
        //			console.log("walkChildren className" + nodeObject[i].qname)
        //			
        //			console.log("walkChildren children " + JSON.stringify(nodeObject[i].children))
        			
        //			if(nodeObject[i].dbo.children != undefined && nodeObject[i].dbo.children.length > 0) {
        //				this.walkChildren(nodeObject[i].dbo.children, previous);
        //			}
        		}
        		
        		
        		
        	}
        	
        	ngAfterViewInit() {
        	    /**
        	     * TODO : Implement Drag & Drop from palette see : https://codepen.io/fxaeberard/pen/reGvjm
        	     * 
        	     */    
        	    let element = this.flowID as ElementRef
                this.paper = new joint.dia.Paper({
                    el: element.nativeElement,
                    width: ''600px'',
                    height: ''300px'',
                    model: this.graph,
                    gridSize: 10,
                        defaultLink: new joint.dia.Link({
                        attrs: {
                            ''.connection'' : {
                                stroke: ''orange'',
                                strokeWidth: 2
                            }
                        }                
                    }),
        			drawGrid: {
        				name: ''dot'',
        				args: {
        					color: ''white''
        				}
        			},
                    defaultRouter: {
                        name: ''manhattan''
                    },
                    defaultConnector: {
                        name: ''rounded''
                    },
                    validateConnection: function(cellViewS, magnetS, cellViewT, magnetT, end, linkView) {
                        // Prevent connections if not on Magnets from ports
                        if (magnetT == undefined|| magnetS ==undefined)
                            return false
                        else
                            return true
                    }
                });
        
        	// minimap paper view
        		let miniMap = document.getElementById(''paper-multiple-papers-small'')
        	    var paperMiniMap = new joint.dia.Paper({
        	        el: miniMap,
        	        model: this.graph,
        	        width: ''100%'',
        	        height: ''300'',
        	        gridSize: 5,
        	        interactive: { elementMove: false },
        //			drawGrid: {
        //				name: ''mesh'',
        //				args: {
        //					color: ''white''
        //				}
        //			}
        	    });
        		this.paperMiniMap = paperMiniMap;
        	    paperMiniMap.scale(this.miniMapScale);
        		/*miniMap.addEventListener(''mousemove'', e => {
        			// console.log("i am minimap event " + JSON.stringify(e));
        			if (this.dragStartPositionMiniMap != null) {
        				console.log("i am minimap dragPosition " + JSON.stringify(this.dragStartPositionMiniMap));
                    paperMiniMap.translate(
                        e.offsetX - this.dragStartPositionMiniMap.x, 
                        e.offsetY - this.dragStartPositionMiniMap.y);
        	    }
        		})
        		*/
        //paperSmall.$el.css(''pointer-events'', ''none'');
        
        		$(''#minimap-navigator'').width(215);
        		$(''#minimap-navigator'').height(108);
        		
        		// Bind container scrolling
        		$(''#flowContainer'').scroll( e => {
        		  $(''#minimap-navigator'').css(
        		    ''top'',
        		    this.minimapNavigatorPosition.minY + e.target.scrollTop * this.miniMapScale
        		  );
        		  $(''#minimap-navigator'').css(
        		    ''left'',
        		    this.minimapNavigatorPosition.minX + e.target.scrollLeft * this.miniMapScale
        		  );
        		}); 
        		
        		// Bind minimap navigator drag
        		var dragFlag = false;
        		var x = 0;
        		var y = 0;
        		var initialOffset = { x: 0, y: 0 };
        		$(''#minimap-navigator'').mousedown( e => {
        		  dragFlag = true;
        		  x = e.clientX;
        		  y = e.clientY;
        		  initialOffset.x = e.target.offsetLeft;
        		  initialOffset.y = e.target.offsetTop;
        		 console.log("initialOffsetX : " + initialOffset.x + '' initialOffsetY : '' + initialOffset.y)
        		});
        		$(''#minimap-navigator'').mouseup( () => {
        		  dragFlag = false;
        		});
        		$(''#minimap-container'').mouseleave( () =>  {
        		  dragFlag = false;
        		});
        		$(''#minimap-navigator'').mousemove( e => {
        		  if (dragFlag) {
        			
        		    var newX = initialOffset.x + e.clientX - x;
        		    var newY = initialOffset.y + e.clientY - y;
        			console.log(''eClientX : '' + e.clientX + '' eClientY : '' + e.clientY)
        			console.log(''x : '' + x + '' y : '' + y)
        			console.log("newX : " + newX + '' newY:'' + newY)
        		    /*if (this.minimapNavigatorPosition.minY > newY) {
        		      newY = this.minimapNavigatorPosition.minY;
        		    }
        		    if (this.minimapNavigatorPosition.minX > newX) {
        		      newX = this.minimapNavigatorPosition.minX;
        		    }
        		    if (this.minimapNavigatorPosition.maxY < newY) {
        		      newY = this.minimapNavigatorPosition.maxY;
        		    }
        		    if (this.minimapNavigatorPosition.maxX < newX) {
        		      newX = this.minimapNavigatorPosition.maxX;
        		    }*/
        		console.log("newX : " + newX + '' newY:'' + newY)
        		    //$(''#minimap-navigator'').css(''top'', newY);
        		    //$(''#minimap-navigator'').css(''left'', newX);
        			// newX / this.miniMapScale
        			console.log(" i am calcul : " + newX *((this.scale/10) / this.miniMapScale))
        			$(''#flowContainer'').scrollLeft(newX *((this.scale/10) / this.miniMapScale));
        		    $(''#flowContainer'').scrollTop(newY *((this.scale/10) / this.miniMapScale));
        			/*
        		    $(''#flowContainer'').scrollLeft((newX - this.minimapNavigatorPosition.maxX) / this.miniMapScale);
        		    $(''#flowContainer'').scrollTop((newY - this.minimapNavigatorPosition.maxY)  / this.miniMapScale);
        */
        		  }
        		});
           
        //        this.paper.on(''blank:pointerdown'', (event, x, y) => {
        //            this.c8o.log.debug("Mouse Start")
        //            this.dragStartPosition = { x: x * this.scale / 10, y: y * this.scale / 10};
        //        });
        //        
        //        this.paper.on(''cell:pointerup blank:pointerup'', (cellView, x, y) => {
        //            this.c8o.log.debug("Mouse Up")
        //            this.dragStartPosition = null
        //        });
        //
        //		this.paperMiniMap.on(''blank:pointerdown'', (event, x, y) => {
        //            this.c8o.log.debug("Mouse Start")
        //            this.dragStartPositionMiniMap = { x: x , y: y };
        //        });
        //        
        //        this.paperMiniMap.on(''cell:pointerup blank:pointerup'', (cellView, x, y) => {
        //            this.c8o.log.debug("Mouse Up")
        //            this.dragStartPositionMiniMap = null
        //        });
                
                this.paper.on(''cell:pointerclick'',  (cellView) => {
                    this.c8o.log.debug("Step clicked !!!")
        //            cellView.model.attributes.attrs[''.label''].refY = -80
        //            let parents = cellView.model.getAncestors();
        //            
        //            this.c8o.log.debug("I AM LENGTH : " + parents.length)
        //            if(parents.length !== 0) {
        //                for(let i = 0; i < parents.length ; i++) {
        //                    let id = parents[i].id;
        //                    let cell = this.graph.getCell(id);
        //                    cell.attributes.attrs[''.label''].refY = -80 * (i + 1.5);
        //                }
        //            }
                    this.getAndDisplayStepChilds(cellView)
                })
                
        	}
        	/*End_c8o_PageFunction*/
        '
segment: path-to-flowviewer
title: Title for FlowViewer
↓PageEvent [ngx.components.UIPageEvent-1588052803545]: 
  ↓useJointJS [ngx.components.UICustomAction-1588052817033]: 
    package_dependencies: 
      - xmlizable: 
        - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
        - com.twinsoft.convertigo.beans.common.XMLVector: 
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
            - com.twinsoft.convertigo.beans.common.XMLVector: 
              - java.lang.String: 
                - ↑value: jointjs
              - java.lang.String: 
                - ↑value: 3.1.1
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
            - com.twinsoft.convertigo.beans.common.XMLVector: 
              - java.lang.String: 
                - ↑value: '@types/lodash'
              - java.lang.String: 
                - ↑value: 3.10.1
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
            - com.twinsoft.convertigo.beans.common.XMLVector: 
              - java.lang.String: 
                - ↑value: '@types/jquery'
              - java.lang.String: 
                - ↑value: '>=3.4.1'
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
            - com.twinsoft.convertigo.beans.common.XMLVector: 
              - java.lang.String: 
                - ↑value: '@types/backbone'
              - java.lang.String: 
                - ↑value: 1.4.1
↓Subscribe_Handler [ngx.components.UIEventSubscriber-1588686865663]: 
  topic: dboFocus
  ↓CallSequence [ngx.components.UIDynamicAction-1588686924736]: 
    beanData: '{"ionBean":"CallSequenceAction","requestable":"plain:C8oStudio.GetGraph"}'
    ↓DisplayFlow [ngx.components.UICustomAction-1588687209815]: 
      actionValue: 
        - xmlizable: 
          - ↑classname: com.twinsoft.convertigo.beans.common.FormatedContent
          - com.twinsoft.convertigo.beans.common.FormatedContent: 
            →: |
              '            class walkTree {
                              
                          }
              		    
                  		this.graph.clear();
              // 			console.log("I AM VARS FLOW" + JSON.stringify(vars.flow));
                  		let previous = null
              
                  		for (var i=0; i < vars.flow.length ; i++) {
                  		    let step = this.addStep({
                      		        x: 30,
                      		        y: 30 + this.verticalSpace * i		        
                      		    }, 
                      		    {
                                      width: 70,
                                      height: 70              
                                  }, 
                                  vars.flow[i].dbo.displayName,
                                  vars.flow[i].dbo.hasChildren,
                                  vars.flow[i].dbo.qname,
                                  vars.flow[i].dbo.className,
              					true,
              					false
                  		    )
                  		    
                  		    if (previous != null)
                  		        this.addLink(previous, step, this.isHorizontal, vars.flow[i].dbo.className)
                  		    previous = step
              				
              				if(vars.flow[i].dbo.children != undefined && vars.flow[i].dbo.children.length > 0) {
              					this.walkChildren(vars.flow[i].dbo.children, previous)
              //					console.log("I AM SETDIMENSIONS : " + this.local.maxX + '' '' + this.local.maxY)
              					this.paper.setDimensions(this.local.maxX, this.local.maxY)
              				}
                  		}
              //			this.walkChildren(vars.flow, null)
                  		resolve();
              '
      ↓flow [ngx.components.UIControlVariable-1588693303067]: 
        varValue: 
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
            - MobileSmartSourceType: source:{"filter":"Sequence","project":"C8oStudio","input":"listen(['C8oStudio.GetChildren'])?.array","model":{"data":[{"sequence":"C8oStudio.GetGraph","marker":""}],"path":"?.array","prefix":"","suffix":"","custom":"","useCustom":false}}
    ↓qname [ngx.components.UIControlVariable-1589811848532]: 
      comment: new variable
      varValue: 
        - xmlizable: 
          - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
          - MobileSmartSourceType: script:out
    ↓level [ngx.components.UIControlVariable-1598523209744]: 
      comment: new variable
      varValue: 
        - xmlizable: 
          - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
          - MobileSmartSourceType: plain:100
↓Grid [ngx.components.UIDynamicElement-1588228737881]: 
  beanData: '{"ionBean":"Grid","Height":"plain:"}'
  tagName: ion-grid
  ↓GridRow [ngx.components.UIDynamicElement-1588228741415]: 
    beanData: |
      '{
       "ionBean": "GridRow",
       "Width": "plain:100%",
       "Height": "plain:300px"
      }'
    tagName: ion-row
    ↓GridCol [ngx.components.UIDynamicElement-1588228746957]: 
      beanData: '{"ionBean":"GridCol","SizeXl":"plain:12"}'
      tagName: ion-col
      ↓Div [ngx.components.UIDynamicElement-1600960364621]: 
        beanData: '{"ionBean":"DivTag"}'
        tagName: div
        ↓Tag [ngx.components.UIElement-1600959915099]: 
          tagName: div
          ↓Attr1 [ngx.components.UIAttribute-1600935208423]: 
            attrName: id
            attrValue: 
              - xmlizable: 
                - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
                - MobileSmartSourceType: plain:flowContainer
          ↓Div [ngx.components.UIDynamicElement-1588137806849]: 
            beanData: '{"ionBean":"DivTag"}'
            identifier: flowID
            tagName: div
            ↓Attr [ngx.components.UIAttribute-1588238054179]: 
              attrName: (document:mousemove)
              attrValue: 
                - xmlizable: 
                  - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
                  - MobileSmartSourceType: plain:onMouseMove($event)
              isEnabled: false
        ↓Style [ngx.components.UIStyle-1600961212571]: 
          styleContent: 
            - xmlizable: 
              - ↑classname: com.twinsoft.convertigo.beans.common.FormatedContent
              - com.twinsoft.convertigo.beans.common.FormatedContent: 
                →: |
                  '/**
                   * Custom properties (sometimes referred to as CSS variables or cascading variables)
                   * are entities defined by CSS authors that contain specific values to be reused throughout a document.
                   * They are set using custom property notation, e.g.: --main-color: black;
                   * and are accessed using the var() function, e.g.: color: var(--main-color);
                   * You can find below your component''s properties you can customize within the page.
                   * If you''d like to make some customizations for whole app, please see your app Style & Theme components.
                   * For more informations see https://ionicframework.com/docs/theming.
                  **/
                  //--ion-grid-column-padding	//Padding for the Column
                  //--ion-grid-column-padding-lg	//Padding for the Column on lg screens and up
                  //--ion-grid-column-padding-md	//Padding for the Column on md screens and up
                  //--ion-grid-column-padding-sm	//Padding for the Column on sm screens and up
                  //--ion-grid-column-padding-xl	//Padding for the Column on xl screens and up
                  //--ion-grid-column-padding-xs	//Padding for the Column on xs screens and up
                  //--ion-grid-columns	//The number of total Columns in the Grid
                  max-height:300px !important;
                  '
      ↓Style [ngx.components.UIStyle-1600961167941]: 
        styleContent: 
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.FormatedContent
            - com.twinsoft.convertigo.beans.common.FormatedContent: 
              →: |
                '/**
                 * Custom properties (sometimes referred to as CSS variables or cascading variables)
                 * are entities defined by CSS authors that contain specific values to be reused throughout a document.
                 * They are set using custom property notation, e.g.: --main-color: black;
                 * and are accessed using the var() function, e.g.: color: var(--main-color);
                 * You can find below your component''s properties you can customize within the page.
                 * If you''d like to make some customizations for whole app, please see your app Style & Theme components.
                 * For more informations see https://ionicframework.com/docs/theming.
                **/
                //--ion-grid-column-padding	//Padding for the Column
                //--ion-grid-column-padding-lg	//Padding for the Column on lg screens and up
                //--ion-grid-column-padding-md	//Padding for the Column on md screens and up
                //--ion-grid-column-padding-sm	//Padding for the Column on sm screens and up
                //--ion-grid-column-padding-xl	//Padding for the Column on xl screens and up
                //--ion-grid-column-padding-xs	//Padding for the Column on xs screens and up
                //--ion-grid-columns	//The number of total Columns in the Grid
                max-height:300px !important;
                '
    ↓GridCol1 [ngx.components.UIDynamicElement-1600682513448]: 
      beanData: '{"ionBean":"GridCol","SizeXl":"plain:2"}'
      isEnabled: false
      tagName: ion-col
      ↓Tag [ngx.components.UIElement-1600681837711]: 
        tagName: div
        ↓Attr [ngx.components.UIAttribute-1600681920905]: 
          attrName: id
          attrValue: 
            - xmlizable: 
              - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
              - MobileSmartSourceType: plain:paper-multiple-papers-small
        ↓Attr1 [ngx.components.UIAttribute-1600682197627]: 
          attrName: (document:mousemove)
          attrValue: 
            - xmlizable: 
              - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
              - MobileSmartSourceType: plain:onMouseMove($event)
  ↓GridRow1 [ngx.components.UIDynamicElement-1588228813856]: 
    beanData: '{"ionBean":"GridRow","Height":"plain:350"}'
    tagName: ion-row
    ↓GridCol [ngx.components.UIDynamicElement-1588228819248]: 
      beanData: '{"ionBean":"GridCol"}'
      tagName: ion-col
      ↓RangeSlider [ngx.components.UIDynamicElement-1588159080969]: 
        beanData: |
          '{
           "ionBean": "Range",
           "Min": "plain:1",
           "Max": "plain:10",
           "Snaps": "plain:true"
          }'
        isEnabled: false
        tagName: ion-range
        ↓Attr [ngx.components.UIAttribute-1588159106785]: 
          attrName: '[(ngModel)]'
          attrValue: 
            - xmlizable: 
              - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
              - MobileSmartSourceType: script:scale
        ↓Attr1 [ngx.components.UIAttribute-1588159608396]: 
          attrName: (ngModelChange)
          attrValue: 
            - xmlizable: 
              - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
              - MobileSmartSourceType: script:onGridSizeChanged()
      ↓Text [ngx.components.UIText-1594042417780]: 
        isEnabled: false
        textValue: 
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
            - MobileSmartSourceType: plain:Show horizontally
      ↓ToggleButton [ngx.components.UIDynamicElement-1594041057759]: 
        beanData: |
          '{
           "ionBean": "Toggle",
           "ControlName": "plain:name1594041057759",
           "DoubleBinding": "script:isHorizontal"
          }'
        isEnabled: false
        tagName: ion-toggle
      ↓Directive [ngx.components.UIControlDirective-1594041985238]: 
        directiveExpression: this.isHorizontal
        directiveName: If
        isEnabled: false
        ↓Button [ngx.components.UIDynamicElement-1594042311511]: 
          beanData: '{"ionBean":"Button"}'
          tagName: ion-button
      ↓Tag [ngx.components.UIElement-1600690556904]: 
        tagName: div
        ↓Attr [ngx.components.UIAttribute-1600690556907]: 
          attrName: id
          attrValue: 
            - xmlizable: 
              - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
              - MobileSmartSourceType: plain:paper-multiple-papers-small
        ↓Attr1 [ngx.components.UIAttribute-1600690556910]: 
          attrName: (document:mousemove)
          attrValue: 
            - xmlizable: 
              - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
              - MobileSmartSourceType: plain:onMouseMoveMiniMap($event)
          isEnabled: false
      ↓Tag1 [ngx.components.UIElement-1600877872727]: 
        tagName: div
        ↓Attr [ngx.components.UIAttribute-1600877917499]: 
          attrName: id
          attrValue: 
            - xmlizable: 
              - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
              - MobileSmartSourceType: plain:minimap-navigator
      ↓Attr [ngx.components.UIAttribute-1600877980416]: 
        attrName: id
        attrValue: 
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
            - MobileSmartSourceType: plain:minimap-container